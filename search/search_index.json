{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Keith Calvelli's Project Portfolio","text":"<p>Welcome! I'm Keith Calvelli, a software engineering manager passionate about building elegant systems and tools. I'm an Orthodox Christian, father of three, and based in North Carolina.</p>"},{"location":"#about-my-work","title":"About My Work","text":"<p>My projects span several areas of interest:</p> <ul> <li>System Architecture - Building modular, declarative systems with NixOS</li> <li>Retro Computing - Bridging vintage Commodore 64 hardware with modern Linux workflows</li> <li>Developer Tools - Creating MCP servers and automation tools for AI-powered development</li> </ul> <p>This portfolio showcases my open-source work, from the axiOS framework to specialized tools for retro computing enthusiasts and developers.</p>"},{"location":"#system","title":"System","text":"<p>System Frameworks</p> Project Description Repository axiOS A modular NixOS distribution kcalvelli/axios"},{"location":"#axios-ecosystem","title":"axiOS Ecosystem","text":"<p>Tools designed for the axiOS framework</p> Project Description Repository axiOS Monitor DMS plugin for monitoring and managing axiOS systems kcalvelli/axios-monitor axiOS AI Mail AI-powered inbox organizer with local LLM classification for axiOS/NixOS kcalvelli/axios-ai-mail axiOS AI Chat Family XMPP chat with AI assistant for the axios ecosystem kcalvelli/axios-ai-chat axiOS DAV Declarative CalDAV/CardDAV sync for NixOS with MCP integration kcalvelli/axios-dav"},{"location":"#commodore-64-tools","title":"Commodore 64 Tools","text":"<p>Projects for Commodore 64 hardware and emulation</p> Project Description Repository C64 Stream Viewer Wayland-native viewer for Ultimate64 video/audio streaming kcalvelli/c64-stream-viewer Ultimate64 MCP Flake to provide MCP server for Ultimate 64 series mainboards kcalvelli/Ultimate64MCP C64 Terminal Terminal for Commodore 64 kcalvelli/c64term"},{"location":"#mcp-servers","title":"MCP Servers","text":"<p>Model Context Protocol server implementations</p> Project Description Repository MCP Journal Journal management via Model Context Protocol kcalvelli/mcp-journal Nix Devshell MCP Creation of Nix devshells via Model Context Protocol kcalvelli/nix-devshell-mcp MCP Gateway Universal MCP Gateway - Aggregates MCP servers with REST, MCP HTTP transport, and OAuth2 authentication kcalvelli/mcp-gateway"},{"location":"#nix-packages","title":"Nix Packages","text":"<p>Flakes to provide packages not included in nixpkgs</p> Project Description Repository Brave Previews Nightly and Beta builds of Brave Browser with preview features kcalvelli/brave-browser-previews"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation and portfolio projects</p> Project Description Repository Engineering Portal Auto-updating portfolio site with GitHub discovery and architectural documentation kcalvelli/kcalvelli-portal"},{"location":"#tabletop-gaming","title":"Tabletop Gaming","text":"<p>Tabletop RPG and gaming projects</p> Project Description Repository Peregrinatio RPG Tabletop RPG project kcalvelli/peregrinatio-rpg"},{"location":"#calendar-tools","title":"Calendar Tools","text":"<p>Calendar and scheduling applications</p> Project Description Repository Orthoterm Orthodox calendar terminal application kcalvelli/orthoterm"},{"location":"Ultimate64MCP/","title":"Ultimate64 MCP","text":"<p>Flake to provide MCP server for Ultimate 64 series mainboards</p> <p>View on GitHub</p>"},{"location":"Ultimate64MCP/#overview","title":"Overview","text":"<p>A Model Context Protocol (MCP) server for the Commodore 64 Ultimate and compatible devices (Ultimate 64, Ultimate II+). This server enables AI assistants like Claude, ChatGPT, and Cursor to control your C64 via the Ultimate's REST API, translating natural language commands into device operations.</p> <p>Supported Devices:</p> <ul> <li>Commodore 64 Ultimate: Official modern Commodore 64 with Ultimate 64 FPGA mainboard</li> <li>Ultimate 64: Original FPGA-based Commodore 64 mainboard by Gideon's Logic</li> <li>Ultimate II+: Cartridge for original C64/C128 adding USB, ethernet, and drive emulation</li> </ul> <p>Key Features:</p> <ul> <li>37 Tools: Comprehensive coverage of Ultimate device functionality</li> <li>Dual Transport Modes: STDIO (local) and SSE (remote/hosted deployments)</li> <li>Dynamic Connection: Set C64 connection at runtime or via environment variable</li> <li>Program Upload: Run PRGs from base64, URLs, or local files</li> <li>Docker Support: Containerized deployment with non-root security</li> <li>Full Device Control: Load programs, manage disks, read/write memory, configure settings, control streaming</li> </ul> <p>Status: Alpha release - tested with Ultimate boards and home network setups</p>"},{"location":"Ultimate64MCP/#architecture","title":"Architecture","text":"<p>The server implements a classic bridge/adapter pattern, translating MCP protocol requests from AI assistants into REST API calls for Ultimate hardware. It operates as a three-layer system: MCP clients communicate via STDIO or SSE, the adapter server translates to REST calls, and the Ultimate device executes operations on actual C64 hardware.</p> <pre><code>C4Component\n    title Component Diagram for Ultimate64 MCP Server\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"User\", \"Interacting with AI assistant\")\n\n    Container_Boundary(mcp_clients, \"MCP Client Layer\") {\n        Component(claudeDesktop, \"Claude Desktop\", \"Anthropic AI\", \"Local AI assistant\")\n        Component(cursor, \"Cursor IDE\", \"AI-powered editor\", \"Code editor with AI\")\n        Component(webClient, \"Web Client\", \"Browser/Custom\", \"Remote AI applications\")\n    }\n\n    Container_Boundary(mcp_server, \"MCP Server (Bridge/Adapter)\") {\n        Component(mcpProtocol, \"MCP Protocol Handler\", \"Python/Starlette\", \"Handles JSON-RPC, tool definitions\")\n        Component(transportLayer, \"Transport Layer\", \"STDIO/SSE\", \"Dual mode: local stdin/stdout or HTTP SSE\")\n        Component(toolExecutor, \"Tool Executor\", \"Python/aiohttp\", \"37 tools: program execution, memory ops, disk management\")\n    }\n\n    Container_Boundary(rest_adapter, \"REST Adapter Layer\") {\n        Component(restClient, \"REST Client\", \"aiohttp\", \"HTTP client for Ultimate API\")\n        Component(prgUploader, \"PRG Uploader\", \"Python\", \"Handles base64/URL/file \u2192 binary upload\")\n        Component(configManager, \"Config Manager\", \"JSON\", \"Connection settings, retries, timeouts\")\n    }\n\n    System_Ext(ultimateDevice, \"Ultimate 64 Hardware\", \"FPGA C64 / Ultimate II+ Cartridge\")\n    System_Ext(c64Hardware, \"C64 Computer\", \"Commodore 64\")\n\n    Rel(user, claudeDesktop, \"Natural language commands\", \"Chat\")\n    Rel(user, cursor, \"Code + AI instructions\", \"IDE interface\")\n    Rel(user, webClient, \"Remote control\", \"HTTPS\")\n\n    BiRel(claudeDesktop, transportLayer, \"MCP messages\", \"STDIO (local)\")\n    BiRel(cursor, transportLayer, \"MCP messages\", \"STDIO (local)\")\n    BiRel(webClient, transportLayer, \"MCP messages\", \"SSE (HTTP)\")\n\n    Rel(transportLayer, mcpProtocol, \"JSON-RPC 2.0 requests\", \"MCP specification\")\n    Rel(mcpProtocol, toolExecutor, \"Tool invocations\", \"37 available tools\")\n\n    Rel(toolExecutor, restClient, \"API requests\", \"HTTP/JSON\")\n    Rel(toolExecutor, prgUploader, \"Upload PRG files\", \"base64/URL/file\")\n    Rel(toolExecutor, configManager, \"Read connection config\", \"C64_HOST, timeout, retries\")\n\n    Rel(restClient, ultimateDevice, \"REST API calls\", \"HTTP port 6464\")\n    Rel(prgUploader, ultimateDevice, \"Binary uploads\", \"POST /v1/run\")\n\n    Rel(ultimateDevice, c64Hardware, \"Controls hardware\", \"FPGA emulation or cartridge interface\")\n\n    UpdateElementStyle(toolExecutor, $bgColor=\"#FF9800\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(mcpProtocol, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Three-layer Bridge Pattern: MCP clients \u2192 Adapter Server \u2192 Target System, with clear separation between protocol handling (MCP), business logic (37 tools), and external communication (REST API)</li> <li>Dual Transport Architecture: Single codebase supports both STDIO (for local MCP clients like Claude Desktop) and SSE (for remote/hosted deployments), selected via command-line flag</li> <li>Stateless REST Adapter: Each tool execution is an independent HTTP request to the Ultimate device; server maintains no persistent connection to C64 hardware</li> <li>Dynamic Connection Management: C64 host can be set via environment variable (<code>C64_HOST</code>), command-line argument, or runtime using <code>ultimate_set_connection</code> tool</li> <li>Three PRG Upload Paths: <code>ultimate_run_prg_binary</code> accepts base64-encoded data (for AI-generated code), HTTP URLs (for remote downloads), or local file paths (for server-side storage)</li> <li>Direct REST Fallback: Exposes <code>/upload-prg</code> endpoint for non-MCP clients or large file uploads bypassing MCP protocol overhead</li> <li>Ultimate API Dependency: All functionality wraps the Ultimate REST API (port 6464 by default); requires Ultimate firmware with API enabled</li> </ul>"},{"location":"Ultimate64MCP/#onboarding","title":"Onboarding","text":""},{"location":"Ultimate64MCP/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>A Commodore 64 Ultimate (or Ultimate 64/II+/II+L) on your network</li> <li>The Ultimate's REST API must be accessible (enabled by default)</li> </ul>"},{"location":"Ultimate64MCP/#quick-start-local-stdio-mode","title":"Quick Start - Local STDIO Mode","text":"<p>For local AI assistants (Claude Desktop, Cursor):</p> <pre><code># Clone the repository\ngit clone https://github.com/kcalvelli/Ultimate64MCP.git\ncd Ultimate64MCP\n\n# Install dependencies\npip install -r requirements.txt\n\n# Run in STDIO mode with your C64's IP\nexport C64_HOST=\"192.168.1.64\"\npython mcp_ultimate_server.py --stdio\n</code></pre>"},{"location":"Ultimate64MCP/#quick-start-sse-mode-remotehosted","title":"Quick Start - SSE Mode (Remote/Hosted)","text":"<p>For remote or hosted deployments:</p> <pre><code># Set your Ultimate device's IP address\nexport C64_HOST=\"192.168.1.64\"\n\n# Start the server (SSE mode is default)\npython mcp_ultimate_server.py\n</code></pre> <p>The server runs on <code>http://0.0.0.0:8000</code> by default.</p>"},{"location":"Ultimate64MCP/#docker-deployment","title":"Docker Deployment","text":"<p>Build the image:</p> <pre><code>cd mcp_hosted\ndocker build -t ultimate64-mcp .\n</code></pre> <p>Run the container:</p> <pre><code># With environment variable\ndocker run -p 8000:8000 -e C64_HOST=192.168.1.64 ultimate64-mcp\n\n# With custom port (if C64 is behind NAT/port forwards)\ndocker run -p 8000:8000 -e C64_HOST=http://192.168.1.64:6464 ultimate64-mcp\n\n# Start without connection (configure later via tool)\ndocker run -p 8000:8000 ultimate64-mcp\n</code></pre>"},{"location":"Ultimate64MCP/#client-configuration","title":"Client Configuration","text":"<p>Cursor IDE - Add to <code>.cursor/mcp.json</code>:</p> <p>For SSE (Remote) Mode:</p> <pre><code>{\n  \"mcpServers\": {\n    \"ultimate64-mcp\": {\n      \"transport\": {\n        \"type\": \"sse\",\n        \"url\": \"http://your-server-address:8000/sse\"\n      }\n    }\n  }\n}\n</code></pre> <p>For STDIO (Local) Mode:</p> <pre><code>{\n  \"mcpServers\": {\n    \"ultimate64-mcp\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/mcp_ultimate_server.py\", \"--stdio\"],\n      \"env\": {\n        \"C64_HOST\": \"192.168.1.64\"\n      }\n    }\n  }\n}\n</code></pre> <p>Claude Desktop - Add to configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"ultimate64-mcp\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/mcp_ultimate_server.py\", \"--stdio\"],\n      \"env\": {\n        \"C64_HOST\": \"192.168.1.64\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"Ultimate64MCP/#available-tools-37-total","title":"Available Tools (37 Total)","text":"<p>Connection Management:</p> <ul> <li><code>ultimate_set_connection</code>, <code>ultimate_get_connection</code>, <code>ultimate_version</code></li> </ul> <p>Program Execution:</p> <ul> <li><code>ultimate_run_program</code>, <code>ultimate_load_program</code>, <code>ultimate_run_prg_binary</code>, <code>ultimate_run_cartridge</code></li> </ul> <p>Audio Playback:</p> <ul> <li><code>ultimate_play_sid</code>, <code>ultimate_play_mod</code></li> </ul> <p>Memory Operations:</p> <ul> <li><code>ultimate_read_memory</code>, <code>ultimate_write_memory</code>, <code>ultimate_write_memory_binary</code></li> </ul> <p>Drive &amp; Disk Management:</p> <ul> <li><code>ultimate_mount_disk</code>, <code>ultimate_unmount_disk</code>, <code>ultimate_turn_drive_on</code>, <code>ultimate_turn_drive_off</code>, <code>ultimate_set_drive_mode</code>, <code>ultimate_load_drive_rom</code>, <code>ultimate_create_d64</code>, <code>ultimate_create_d71</code>, <code>ultimate_create_d81</code>, <code>ultimate_create_dnp</code></li> </ul> <p>Machine Control:</p> <ul> <li><code>ultimate_reset_machine</code>, <code>ultimate_soft_reset</code>, <code>ultimate_reboot_device</code>, <code>ultimate_power_off</code>, <code>ultimate_get_machine_info</code>, <code>ultimate_get_machine_state</code></li> </ul> <p>Configuration:</p> <ul> <li><code>ultimate_get_config_categories</code>, <code>ultimate_get_config_category</code>, <code>ultimate_get_config_item</code>, <code>ultimate_set_config_item</code>, <code>ultimate_bulk_config_update</code>, <code>ultimate_save_config</code>, <code>ultimate_load_config</code>, <code>ultimate_reset_config</code></li> </ul> <p>File Operations:</p> <ul> <li><code>ultimate_get_file_info</code></li> </ul> <p>Streaming (Ultimate 64 Only):</p> <ul> <li><code>ultimate_start_stream</code>, <code>ultimate_stop_stream</code></li> </ul>"},{"location":"Ultimate64MCP/#running-programs-remotely","title":"Running Programs Remotely","text":"<p>The <code>ultimate_run_prg_binary</code> tool supports three input methods:</p> <p>1. Base64-Encoded PRG (AI-generated code):</p> <pre><code>{\n  \"name\": \"ultimate_run_prg_binary\",\n  \"arguments\": {\n    \"prg_data_base64\": \"AQgLCJ4ACJ4ACQoAHgoAoCAKgBQKgP8f...\"\n  }\n}\n</code></pre> <p>2. URL Download:</p> <pre><code>{\n  \"name\": \"ultimate_run_prg_binary\",\n  \"arguments\": {\n    \"url\": \"https://csdb.dk/getinternalfile.php/12345/game.prg\"\n  }\n}\n</code></pre> <p>3. Server-Local File:</p> <pre><code>{\n  \"name\": \"ultimate_run_prg_binary\",\n  \"arguments\": {\n    \"file_path\": \"/workspace/demos/mydemo.prg\"\n  }\n}\n</code></pre>"},{"location":"Ultimate64MCP/#troubleshooting","title":"Troubleshooting","text":"<p>Connection Issues:</p> <ol> <li>Verify your Commodore 64 Ultimate is powered on and connected to the network</li> <li>Check the IP address in the Ultimate menu (F2 \u2192 Network settings)</li> <li>Ensure the REST API is enabled (it is by default)</li> <li>Test connectivity: <code>curl http://&lt;C64_HOST&gt;/v1/version</code></li> </ol> <p>\"No C64 host configured\" Error:</p> <p>Either:</p> <ul> <li>Set the <code>C64_HOST</code> environment variable</li> <li>Pass the URL as a command-line argument</li> <li>Use the <code>ultimate_set_connection</code> tool after startup</li> </ul>"},{"location":"Ultimate64MCP/#release-history","title":"Release History","text":"Version Date Status - - No releases found"},{"location":"axios-ai-chat/","title":"axiOS AI Chat","text":"<p>Family XMPP chat with AI assistant for the axios ecosystem.</p>"},{"location":"axios-ai-chat/#overview","title":"Overview","text":"<p>A family-oriented XMPP chat system with an integrated AI assistant, designed for the axios ecosystem. Like a private AIM, but only accessible within your Tailscale network, with an AI bot that can manage email, calendar, contacts, and more through MCP tools.</p> <p>Repository: kcalvelli/axios-ai-chat</p>"},{"location":"axios-ai-chat/#architecture","title":"Architecture","text":"<pre><code>C4Component\n    title axiOS AI Chat - Component Diagram\n\n    Container_Boundary(tailnet, \"Tailscale Network\") {\n        Component(clients, \"XMPP Clients\", \"Conversations/Gajim/Dino\", \"Native chat applications\")\n        Component(prosody, \"Prosody Server\", \"XMPP Server\", \"Message routing and presence\")\n        Component(bot, \"axios-ai-bot\", \"Python\", \"AI assistant with intent routing\")\n    }\n\n    System_Ext(claude, \"Claude API\", \"LLM for natural language\")\n    System_Ext(gateway, \"mcp-gateway\", \"Tool execution endpoint\")\n\n    Rel(clients, prosody, \"XMPP\", \"Messages\")\n    Rel(prosody, bot, \"XMPP\", \"@ai mentions\")\n    Rel(bot, claude, \"API calls\", \"HTTPS\")\n    Rel(bot, gateway, \"Tool execution\", \"HTTP/MCP\")\n\n    UpdateElementStyle(bot, $bgColor=\"#1168bd\")</code></pre> <p>Key Features: - Private Family Messenger - Accessible only within your Tailscale network - AI Assistant - Chat with <code>@ai</code> to manage email, calendar, contacts - Native Clients - Works with Conversations (Android), Gajim (Windows/Linux), Dino (Linux) - Dynamic Tool Discovery - New MCP servers added to mcp-gateway are automatically available - Cost-Optimized - Uses Haiku for intent classification, Sonnet for tool execution</p>"},{"location":"axios-ai-chat/#onboarding","title":"Onboarding","text":""},{"location":"axios-ai-chat/#prerequisites","title":"Prerequisites","text":"<ul> <li>NixOS with flakes enabled</li> <li>Tailscale configured</li> <li>mcp-gateway running</li> </ul>"},{"location":"axios-ai-chat/#installation","title":"Installation","text":"<p>Add to your <code>flake.nix</code>:</p> <pre><code>{\n  inputs.axios-chat.url = \"github:kcalvelli/axios-chat\";\n\n  outputs = { self, nixpkgs, axios-chat, ... }: {\n    nixosConfigurations.myhost = nixpkgs.lib.nixosSystem {\n      modules = [\n        axios-chat.nixosModules.default\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre>"},{"location":"axios-ai-chat/#configuration","title":"Configuration","text":"<pre><code>services.axios-chat = {\n  prosody = {\n    enable = true;\n    domain = \"chat.home.ts.net\";\n    tailscaleIP = \"100.64.0.1\";\n  };\n  bot = {\n    enable = true;\n    xmppDomain = \"chat.home.ts.net\";\n    xmppPasswordFile = config.age.secrets.ai-bot-password.path;\n    anthropicKeyFile = config.age.secrets.anthropic-key.path;\n    mcpGatewayUrl = \"http://localhost:8085\";\n  };\n};\n</code></pre>"},{"location":"axios-ai-chat/#release-history","title":"Release History","text":"<p>No releases yet.</p>"},{"location":"axios-ai-mail/","title":"axiOS AI Mail","text":"<p>AI-powered inbox organizer with local LLM classification for axiOS/NixOS</p> <p>View on GitHub</p>"},{"location":"axios-ai-mail/#overview","title":"Overview","text":"<p>axiOS AI Mail is a declarative email management system that combines direct provider integration (Gmail, IMAP) with local AI classification to automatically organize your inbox. Messages are tagged, prioritized, and organized\u2014all locally, with zero cloud dependencies for AI processing.</p> <p>Key Features:</p> <ul> <li>AI-Powered Classification: Automatically tags messages with categories like <code>work</code>, <code>finance</code>, <code>personal</code>, <code>shopping</code> using local LLMs via Ollama</li> <li>Multi-Account Support: Manage Gmail (OAuth2) and IMAP accounts from a single interface</li> <li>Modern Web UI: Responsive React interface with Material-UI, dark mode, and PWA support</li> <li>Mobile-Optimized: Touch gestures, swipe actions, and responsive design for mobile devices</li> <li>Keyboard Navigation: Full keyboard shortcut support (j/k navigation, quick actions)</li> <li>Real-Time Sync: WebSocket-based live updates across all connected clients</li> <li>Bulk Operations: Select multiple messages for batch actions with undo support</li> <li>Declarative Config: Define everything in Nix\u2014accounts, AI settings, custom tags</li> </ul> <p>Note: This application is designed for axiOS users and assumes axiOS conventions (agenix for secrets, <code>~/.config/nixos_config</code> for configuration).</p>"},{"location":"axios-ai-mail/#architecture","title":"Architecture","text":"<p>The application follows a layered architecture with clear separation between the React frontend, FastAPI backend, email providers, and AI classification engine.</p> <pre><code>C4Component\n    title Component Diagram for axiOS AI Mail\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"axiOS User\", \"Email user managing multiple accounts\")\n\n    Container_Boundary(web_ui, \"Web Interface\") {\n        Component(reactApp, \"React App\", \"TypeScript/Vite\", \"Material-UI components, React Query, Zustand state\")\n        Component(pwa, \"PWA Shell\", \"Service Worker\", \"Offline support, installable app\")\n    }\n\n    Container_Boundary(backend, \"FastAPI Backend\") {\n        Component(api, \"REST API\", \"Python/FastAPI\", \"Message CRUD, search, sync triggers\")\n        Component(websocket, \"WebSocket Manager\", \"FastAPI WebSockets\", \"Real-time sync notifications\")\n        Component(syncEngine, \"Sync Engine\", \"Python\", \"Orchestrates fetch, classify, store\")\n    }\n\n    Container_Boundary(providers, \"Email Providers\") {\n        Component(gmailProvider, \"Gmail Provider\", \"Google API Client\", \"OAuth2 auth, label sync\")\n        Component(imapProvider, \"IMAP Provider\", \"imaplib/smtplib\", \"Password auth, KEYWORD sync\")\n    }\n\n    System_Ext(ollama, \"Ollama\", \"Local LLM Runtime\")\n    System_Ext(gmail, \"Gmail API\", \"Google Cloud\")\n    System_Ext(imapServer, \"IMAP Server\", \"Fastmail, ProtonMail, etc.\")\n    System_Ext(database, \"SQLite\", \"Local Database\")\n\n    Rel(user, reactApp, \"Views/manages email\", \"Browser/PWA\")\n    BiRel(reactApp, api, \"REST requests\", \"HTTP/JSON\")\n    BiRel(reactApp, websocket, \"Live updates\", \"WebSocket\")\n\n    Rel(api, syncEngine, \"Triggers sync\", \"Internal call\")\n    Rel(syncEngine, gmailProvider, \"Fetches messages\", \"Gmail API\")\n    Rel(syncEngine, imapProvider, \"Fetches messages\", \"IMAP4\")\n    Rel(syncEngine, ollama, \"Classifies messages\", \"HTTP/JSON\")\n    Rel(syncEngine, database, \"Stores messages/tags\", \"SQLAlchemy\")\n\n    Rel(gmailProvider, gmail, \"OAuth2 requests\", \"HTTPS\")\n    Rel(imapProvider, imapServer, \"IMAP commands\", \"IMAP4/TLS\")\n\n    Rel(websocket, reactApp, \"Broadcasts updates\", \"JSON events\")\n\n    UpdateElementStyle(syncEngine, $bgColor=\"#FF9800\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(ollama, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Nix-Centric Design: Configuration is declarative via Home Manager module, generating runtime config at build time</li> <li>Provider Abstraction: BaseEmailProvider interface allows adding new providers (Outlook planned) without changing core logic</li> <li>Local-First AI: All classification runs via Ollama on local hardware, no cloud API calls for AI</li> <li>SQLite Storage: Messages and tags stored in local SQLite database with full-text search</li> <li>Real-Time Architecture: WebSocket broadcasts sync events to all connected clients for instant updates</li> <li>Secret Management: OAuth tokens and passwords managed via agenix/sops-nix, never stored in plaintext</li> </ul>"},{"location":"axios-ai-mail/#onboarding","title":"Onboarding","text":""},{"location":"axios-ai-mail/#prerequisites","title":"Prerequisites","text":"<ol> <li>axiOS or NixOS with Home Manager - Nix-native application</li> <li>Ollama - For local AI classification (<code>ollama pull llama3.2</code>)</li> <li>Google Cloud OAuth credentials (for Gmail accounts)</li> </ol>"},{"location":"axios-ai-mail/#installation","title":"Installation","text":"<p>Add to your flake inputs:</p> <pre><code>{\n  inputs.axios-ai-mail.url = \"github:kcalvelli/axios-ai-mail\";\n}\n</code></pre> <p>Enable in Home Manager:</p> <pre><code>{ config, ... }:\n{\n  imports = [ inputs.axios-ai-mail.homeManagerModules.default ];\n\n  programs.axios-ai-mail = {\n    enable = true;\n\n    ai = {\n      model = \"llama3.2\";\n      endpoint = \"http://localhost:11434\";\n    };\n\n    accounts.gmail = {\n      provider = \"gmail\";\n      email = \"you@gmail.com\";\n      oauthTokenFile = config.age.secrets.gmail-token.path;\n    };\n  };\n}\n</code></pre>"},{"location":"axios-ai-mail/#usage","title":"Usage","text":"<pre><code># Sync messages from all accounts\naxios-ai-mail sync run\n\n# Start the web interface\naxios-ai-mail web\n# Open http://localhost:8080\n\n# Gmail OAuth setup wizard\naxios-ai-mail auth gmail --account personal\n</code></pre>"},{"location":"axios-ai-mail/#documentation","title":"Documentation","text":"<ul> <li>Quick Start Guide - Get running in 15 minutes</li> <li>User Guide - Complete feature documentation</li> <li>Configuration Reference - All Nix options</li> </ul>"},{"location":"axios-ai-mail/#release-history","title":"Release History","text":"Version Date Status - - No releases yet"},{"location":"axios-dav/","title":"axiOS DAV","text":"<p>Declarative CalDAV/CardDAV sync for NixOS with MCP integration.</p>"},{"location":"axios-dav/#overview","title":"Overview","text":"<p>axios-dav provides declarative CalDAV/CardDAV synchronization for NixOS, with first-class Google Calendar support and an MCP server for AI agents to read/create calendar events and search contacts.</p> <p>Repository: kcalvelli/axios-dav</p>"},{"location":"axios-dav/#architecture","title":"Architecture","text":"<pre><code>C4Component\n    title axiOS DAV - Component Diagram\n\n    Container_Boundary(dav, \"axios-dav\") {\n        Component(nixmod, \"NixOS Module\", \"Nix\", \"Declarative configuration\")\n        Component(vdirsyncer, \"vdirsyncer\", \"Python\", \"CalDAV/CardDAV sync engine\")\n        Component(khal, \"khal\", \"Python\", \"Calendar CLI\")\n        Component(khard, \"khard\", \"Python\", \"Contacts CLI\")\n        Component(mcp, \"MCP Server\", \"Python\", \"AI agent interface\")\n    }\n\n    System_Ext(google, \"Google Calendar/Contacts\", \"OAuth2 provider\")\n    System_Ext(caldav, \"CalDAV Servers\", \"Fastmail, Nextcloud, etc.\")\n    System_Ext(ai, \"AI Agents\", \"Claude Code, axios-ai-chat\")\n\n    Rel(nixmod, vdirsyncer, \"Generates config\", \"Nix\")\n    Rel(vdirsyncer, google, \"Syncs\", \"OAuth2/CalDAV\")\n    Rel(vdirsyncer, caldav, \"Syncs\", \"CalDAV/CardDAV\")\n    Rel(khal, vdirsyncer, \"Reads\", \"Local storage\")\n    Rel(ai, mcp, \"Tool calls\", \"MCP\")\n    Rel(mcp, khal, \"Queries\", \"CLI\")\n\n    UpdateElementStyle(dav, $bgColor=\"#1168bd\")</code></pre> <p>Key Features: - Declarative Configuration - No manual config files; everything in Nix - Google Calendar &amp; Contacts - First-class OAuth support - CalDAV/CardDAV - Works with any standard provider (Fastmail, Nextcloud, etc.) - HTTP/ICS Subscriptions - Read-only calendar feeds (holidays, sports, etc.) - MCP Server - AI agents can read/create calendar events and search contacts</p>"},{"location":"axios-dav/#onboarding","title":"Onboarding","text":""},{"location":"axios-dav/#installation","title":"Installation","text":"<p>Add to your <code>flake.nix</code>:</p> <pre><code>{\n  inputs.axios-dav.url = \"github:kcalvelli/axios-dav\";\n\n  outputs = { self, nixpkgs, home-manager, axios-dav, ... }: {\n    nixosConfigurations.myhost = nixpkgs.lib.nixosSystem {\n      modules = [\n        axios-dav.nixosModules.default\n        home-manager.nixosModules.home-manager\n      ];\n    };\n  };\n}\n</code></pre>"},{"location":"axios-dav/#configuration","title":"Configuration","text":"<pre><code>services.pim.calendar = {\n  enable = true;\n  defaultCalendar = \"Family\";\n\n  accounts = {\n    google = {\n      type = \"google\";\n      tokenFile = \"/home/youruser/.vdirsyncer/google_token.json\";\n      clientId = \"your-client-id.apps.googleusercontent.com\";\n      clientSecretFile = \"/run/agenix/google-client-secret\";\n    };\n  };\n\n  sync = {\n    frequency = \"5m\";\n    conflictResolution = \"remote\";\n  };\n};\n</code></pre>"},{"location":"axios-dav/#initial-setup","title":"Initial Setup","text":"<pre><code># Discover and authorize calendars\nvdirsyncer discover\n\n# Initial sync\nvdirsyncer sync\n\n# Verify with khal\nkhal list\n</code></pre>"},{"location":"axios-dav/#release-history","title":"Release History","text":"<p>No releases yet.</p>"},{"location":"axios-monitor/","title":"axiOS Monitor","text":"<p>DMS plugin for monitoring and managing axiOS systems</p> <p>View on GitHub</p>"},{"location":"axios-monitor/#overview","title":"Overview","text":"<p>axiOS Monitor is a DankMaterialShell plugin exclusively designed for axiOS systems. It provides integrated rebuild and update tracking capabilities directly from the desktop shell. This is a fork of nix-monitor by Anton Andersson, with significant axiOS-specific modifications.</p> <p>Key Features:</p> <ul> <li>Dual Rebuild Buttons: Separate \"Rebuild Switch\" (immediate activation) and \"Rebuild Boot\" (activate on next boot) actions</li> <li>axiOS Version Tracking: Monitors axiOS library version from flake.lock instead of nixpkgs</li> <li>Zero Configuration: Automatically configured when using axiOS desktop module</li> <li>Real-time Console: View nixos-rebuild output as it runs</li> <li>Update Status: Visual indicators (green/yellow/red) for axiOS update availability</li> <li>System Statistics: Monitor NixOS generations count and Nix store size with configurable warnings</li> <li>Garbage Collection: Trigger nix-collect-garbage directly from the UI</li> </ul> <p>Note: This plugin is exclusively designed for axiOS and will NOT work with standard NixOS installations.</p>"},{"location":"axios-monitor/#architecture","title":"Architecture","text":"<p>The plugin operates as a QML-based desktop widget that bridges user interactions with system-level Nix operations. It uses configurable shell commands to interface with NixOS, flake management, and GitHub APIs for version tracking.</p> <pre><code>C4Component\n    title Component Diagram for axiOS Monitor Plugin\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"axiOS User\", \"Desktop user managing their system\")\n\n    Container_Boundary(desktop_env, \"Desktop Environment\") {\n        Component(barWidget, \"Bar Widget\", \"QML/QuickShell\", \"Shows generations, store size, update status\")\n        Component(popoutPanel, \"Popout Panel\", \"QML/QuickShell\", \"Detailed stats, console output, action buttons\")\n        Component(settingsUI, \"Settings Panel\", \"QML/QuickShell\", \"Configuration interface\")\n    }\n\n    Container_Boundary(plugin_core, \"Plugin Core\") {\n        Component(commandRunner, \"Command Runner\", \"JavaScript/QML Process\", \"Executes shell commands, streams stdout/stderr\")\n        Component(configManager, \"Config Manager\", \"JSON\", \"Loads commands from config.json\")\n    }\n\n    System_Ext(dms, \"DankMaterialShell\", \"GTK/QML Desktop Shell\")\n    System_Ext(nixos, \"NixOS System\", \"Linux OS\")\n    System_Ext(flakeLock, \"flake.lock\", \"JSON file\")\n    System_Ext(github, \"GitHub API\", \"HTTP/JSON\")\n\n    Rel(user, barWidget, \"Views system status\", \"Click\")\n    Rel(user, popoutPanel, \"Triggers rebuild/GC\", \"Button click\")\n    Rel(user, settingsUI, \"Configures intervals &amp; thresholds\", \"DMS Settings\")\n\n    BiRel(barWidget, popoutPanel, \"Opens/closes panel\", \"UI events\")\n    Rel(popoutPanel, commandRunner, \"Executes rebuild/GC\", \"QML Process API\")\n    Rel(commandRunner, configManager, \"Loads command definitions\", \"JSON parse\")\n\n    Rel(commandRunner, nixos, \"Runs nixos-rebuild switch/boot\", \"sudo shell command\")\n    Rel(commandRunner, nixos, \"Runs nix-collect-garbage\", \"shell command\")\n    Rel(commandRunner, flakeLock, \"Parses local axiOS revision\", \"jq query\")\n    Rel(commandRunner, github, \"Fetches remote axiOS revision\", \"git ls-remote\")\n\n    Rel(commandRunner, barWidget, \"Updates stats every 5min\", \"Timer signal\")\n    Rel(commandRunner, popoutPanel, \"Streams command output\", \"stdout/stderr\")\n\n    Rel(dms, barWidget, \"Hosts widget\", \"Plugin system\")\n\n    UpdateElementStyle(commandRunner, $bgColor=\"#FF9800\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>QML Plugin Architecture: Built as a QuickShell plugin loaded by DankMaterialShell at runtime via plugin.json manifest</li> <li>Command-based Integration: All system interactions happen through configurable shell commands (defined in config.json) rather than direct Nix library calls</li> <li>Three-layer UI: Bar widget for glanceable status, popout panel for detailed operations, and DMS settings integration for configuration</li> <li>Process-based Execution: Uses QML Process component to spawn shell commands, capture stdout/stderr in real-time, and stream to console widget</li> <li>Flake-centric Design: Assumes axiOS configuration is a flake with axios as an input, reads flake.lock for local version, uses git ls-remote for remote version</li> <li>Auto-configuration: axiOS desktop module automatically generates config.json with proper commands (<code>$FLAKE_PATH</code> detection, hostname interpolation)</li> <li>No Standalone Operation: Requires DankMaterialShell plugin system and QuickShell runtime, cannot run independently</li> </ul>"},{"location":"axios-monitor/#onboarding","title":"Onboarding","text":""},{"location":"axios-monitor/#for-axios-users-automatic","title":"For axiOS Users (Automatic)","text":"<p>If you're using axiOS with the desktop module enabled (<code>modules.desktop = true</code>), this plugin is automatically configured - no additional setup required!</p> <p>The plugin is included as part of the axiOS desktop module and will:</p> <ul> <li>Auto-detect your flake location via <code>$FLAKE_PATH</code> or default to <code>~/.config/nixos_config</code></li> <li>Configure rebuild commands matching axiOS fish functions</li> <li>Track axiOS library version for updates</li> <li>Enable all features with sensible defaults</li> </ul> <p>Simply rebuild your system and the widget will appear in DMS.</p>"},{"location":"axios-monitor/#activation-steps","title":"Activation Steps","text":"<ol> <li>Rebuild your axiOS configuration: <code>sudo nixos-rebuild switch</code></li> <li>Restart DMS: <code>dms restart</code> (or log out and back in)</li> <li>Open DMS Settings \u2192 Plugins</li> <li>Click \"Scan for Plugins\"</li> <li>Toggle \"axiOS Monitor\" ON</li> <li>Add to your DankBar layout</li> </ol>"},{"location":"axios-monitor/#updating-the-plugin","title":"Updating the Plugin","text":"<p>The plugin updates automatically when you update your axiOS flake input:</p> <pre><code># Update axiOS (includes axios-monitor)\nnix flake update axios\n\n# Rebuild\nsudo nixos-rebuild switch\n\n# Clear QML cache and restart DMS\nrm -rf ~/.cache/quickshell/qmlcache/\ndms restart\n</code></pre> <p>Note: Due to QML disk caching with Nix symlinks, you must clear the QML cache after plugin updates for changes to take effect.</p>"},{"location":"axios-monitor/#manual-configuration-advanced","title":"Manual Configuration (Advanced)","text":"<p>If you need custom configuration, you can override the defaults in your home-manager configuration:</p> <pre><code>{\n  programs.axios-monitor = {\n    enable = true;\n\n    # Override rebuild commands if needed\n    rebuildCommand = [\n      \"bash\" \"-c\"\n      ''\n        FLAKE_PATH=''${FLAKE_PATH:-~/.config/nixos_config}\n        sudo nixos-rebuild switch --flake \"$FLAKE_PATH#$(hostname)\" 2&gt;&amp;1\n      ''\n    ];\n\n    rebuildBootCommand = [\n      \"bash\" \"-c\"\n      ''\n        FLAKE_PATH=''${FLAKE_PATH:-~/.config/nixos_config}\n        sudo nixos-rebuild boot --flake \"$FLAKE_PATH#$(hostname)\" 2&gt;&amp;1\n      ''\n    ];\n\n    # Customize update interval\n    updateInterval = 300; # 5 minutes\n  };\n}\n</code></pre>"},{"location":"axios-monitor/#release-history","title":"Release History","text":"Version Date Status - - No releases found"},{"location":"axios/","title":"axiOS","text":""},{"location":"axios/#overview","title":"Overview","text":"<p>axiOS is a modular NixOS framework and library designed for building reproducible systems with curated desktop environments, development tools, and modern workflows. It follows a library design philosophy, allowing users to import it into their own flakes and maintain minimal configuration while benefiting from a full-featured system.</p> <p>Repository: kcalvelli/axios</p>"},{"location":"axios/#architecture","title":"Architecture","text":"<pre><code>C4Context\n    title System Context: axiOS Framework\n\n    Person(user, \"System User\", \"Developer or desktop user\")\n\n    System_Boundary(axios_boundary, \"axiOS Framework\") {\n        System(axios, \"axiOS\", \"Nix/NixOS\", \"Modular NixOS framework providing desktop, development, and system modules\")\n    }\n\n    System_Ext(nixpkgs, \"NixOS/nixpkgs\", \"Base NixOS system and package repository\")\n    System_Ext(home_manager, \"Home Manager\", \"User environment management\")\n    System_Ext(flathub, \"Flathub\", \"Application distribution platform\")\n    System_Ext(github, \"GitHub\", \"Source repository and updates\")\n    System_Ext(niri, \"Niri Compositor\", \"Wayland compositor with scrollable tiling\")\n    System_Ext(dms, \"DankMaterialShell\", \"Material Design shell and widgets\")\n\n    Rel(user, axios, \"Configures system via\", \"Nix flakes\")\n    BiRel(axios, nixpkgs, \"Extends and builds upon\", \"Nix modules\")\n    Rel(axios, home_manager, \"Integrates for user config\", \"Nix modules\")\n    Rel(axios, flathub, \"Provides app distribution\", \"Flatpak\")\n    Rel(axios, github, \"Fetches updates from\", \"Git/Nix\")\n    Rel(axios, niri, \"Includes and configures\", \"Wayland protocol\")\n    Rel(axios, dms, \"Integrates desktop shell\", \"IPC\")\n\n    UpdateElementStyle(axios, $bgColor=\"#4A90E2\", $fontColor=\"#FFFFFF\", $borderColor=\"#2E5C8A\")\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")</code></pre>"},{"location":"axios/#architectural-assumptions","title":"Architectural Assumptions","text":"<p>axiOS is designed as a framework/library rather than a personal configuration:</p> <ol> <li>Modular Architecture: Users import axios into their flake and enable only needed features through the <code>modules</code> configuration</li> <li>Minimal User Config: Users maintain ~30 lines of configuration while axios provides the complete system</li> <li>Multi-layer Integration: Combines NixOS system modules, Home Manager user configs, and external applications (via Flathub)</li> <li>External Dependencies: Relies on established ecosystem projects (nixpkgs, home-manager, niri, etc.) rather than reimplementing functionality</li> <li>Update Flexibility: Users control when to update via <code>nix flake update</code>, allowing version pinning for stability</li> </ol> <p>The diagram shows axiOS as a central framework that orchestrates these external systems to provide a cohesive desktop and development experience.</p>"},{"location":"axios/#onboarding","title":"Onboarding","text":""},{"location":"axios/#prerequisites","title":"Prerequisites","text":"<ul> <li>NixOS installed in UEFI mode (BIOS/MBR not supported)</li> <li>Git installed</li> <li>Nix flakes and commands enabled</li> </ul>"},{"location":"axios/#quick-start-with-interactive-generator-recommended","title":"Quick Start with Interactive Generator (Recommended)","text":"<pre><code>mkdir ~/my-nixos-config &amp;&amp; cd ~/my-nixos-config\nnix run --refresh --extra-experimental-features \"nix-command flakes\" github:kcalvelli/axios#init\n</code></pre> <p>The <code>--refresh</code> flag ensures you get the latest version.</p>"},{"location":"axios/#manual-setup","title":"Manual Setup","text":"<p>Create three files:</p> <ol> <li>flake.nix (~30 lines) - Import axios and configure your system</li> <li>user.nix (~15 lines) - Your user account settings</li> <li>hardware.nix - Hardware configuration from <code>nixos-generate-config</code></li> </ol> <p>Example <code>flake.nix</code>:</p> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";\n    axios.url = \"github:kcalvelli/axios\";\n  };\n\n  outputs = { self, nixpkgs, axios }: {\n    nixosConfigurations.myhost = axios.lib.mkSystem {\n      hostname = \"myhost\";\n      formFactor = \"desktop\";  # or \"laptop\"\n      hardware = { cpu = \"amd\"; gpu = \"amd\"; };\n      modules = { desktop = true; development = true; };\n      userModulePath = ./user.nix;\n      hardwareConfigPath = ./hardware.nix;\n    };\n  };\n}\n</code></pre>"},{"location":"axios/#building-and-deploying","title":"Building and Deploying","text":"<pre><code># Build the system\nnix build .#nixosConfigurations.myhost.config.system.build.toplevel\n\n# Switch to the new configuration\nsudo nixos-rebuild switch --flake .#myhost\n</code></pre>"},{"location":"axios/#installing-additional-applications","title":"Installing Additional Applications","text":"<p>Use Flathub (Recommended): Open GNOME Software and install applications from Flathub for sandboxed, independently-updating apps.</p> <p>Declarative Packages: Add packages to <code>extraConfig</code> in your host configuration for system-level tools and CLI utilities.</p> <p>For complete installation instructions, see the Installation Guide.</p>"},{"location":"axios/#release-history","title":"Release History","text":"Version Date Status v2026.01.13 2026-01-13 \u2705 Latest v2025.12.11 2025-12-11 v2025.12.04 2025-12-04 v2025.11.21 2025-11-21 v2025.11.19 2025-11-19 v2025.11.18 2025-11-18 v2025.11.13 2025-11-13 2025-11-08.1 2025-11-08 v2025.11.08 2025-11-08 2025-11-04 2025-11-04"},{"location":"brave-browser-previews/","title":"Brave Browser Previews","text":"<p>Nightly and Beta builds of Brave Browser with preview features</p> <p>View on GitHub</p>"},{"location":"brave-browser-previews/#overview","title":"Overview","text":"<p>A Nix Flake that provides the latest Nightly and Beta versions of Brave Browser for Linux (<code>x86_64-linux</code>). This repository is automatically updated daily to track the official Brave GitHub Releases.</p> <p>Key Features:</p> <ul> <li>Automated Updates: GitHub Action runs daily to fetch the latest versions and SRI hashes directly from Brave's release API</li> <li>Two Channels: brave-nightly (bleeding-edge with AI features enabled) and brave-beta (beta channel)</li> <li>Pure Flake: Designed to be easily consumed as a flake input in NixOS or Home Manager configurations</li> <li>NixOS Module: Exports a module allowing configuration similar to <code>programs.chromium</code></li> <li>Ad-hoc Usage: Can run browsers directly via <code>nix run</code> without installation</li> </ul> <p>Note: Brave Nightly is enabled with <code>--enable-features=BraveAIChatAgentProfile</code> by default for AI Agent testing.</p>"},{"location":"brave-browser-previews/#architecture","title":"Architecture","text":"<p>This flake functions as an automated packaging pipeline that bridges Brave's binary releases with the Nix ecosystem. It continuously monitors upstream releases, packages them with proper Nix derivations, and exposes them through multiple consumption patterns.</p> <pre><code>C4Component\n    title Component Diagram for Brave Browser Previews Flake\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"NixOS User\", \"Consuming Brave preview builds\")\n\n    Container_Boundary(flake_outputs, \"Flake Outputs\") {\n        Component(packages, \"Packages\", \"Nix Derivations\", \"brave-nightly, brave-beta\")\n        Component(nixosModule, \"NixOS Module\", \"Nix Module\", \"programs.brave-nightly/beta configuration\")\n        Component(overlay, \"Overlay\", \"Nixpkgs Overlay\", \"Adds packages to pkgs\")\n    }\n\n    Container_Boundary(automation, \"Automation Layer\") {\n        Component(updateScript, \"Update Script\", \"Bash\", \"Queries GitHub API, fetches SRI hashes\")\n        Component(githubAction, \"GitHub Action\", \"CI/CD Workflow\", \"Runs daily, commits updates\")\n    }\n\n    System_Ext(braveReleases, \"Brave Releases\", \"GitHub API/Releases\")\n    System_Ext(nixpkgs, \"Nixpkgs\", \"Package Repository\")\n    System_Ext(debAssets, \"Debian Packages\", \"amd64.deb files\")\n\n    Rel(user, packages, \"Imports as flake input\", \"flake.nix\")\n    Rel(user, nixosModule, \"Enables programs.brave-nightly\", \"NixOS module\")\n    Rel(user, packages, \"Runs directly\", \"nix run github:kcalvelli/...\")\n\n    Rel(nixosModule, overlay, \"Applies overlay\", \"nixpkgs.overlays\")\n    Rel(overlay, packages, \"Provides packages\", \"pkgs.brave-nightly\")\n\n    Rel(githubAction, updateScript, \"Executes daily\", \"Cron: 0 12 * * *\")\n    Rel(updateScript, braveReleases, \"Queries latest versions\", \"GitHub API\")\n    Rel(updateScript, debAssets, \"Fetches .deb files\", \"nix-prefetch-url\")\n    Rel(updateScript, packages, \"Updates version &amp; SRI hash\", \"Modifies .nix files\")\n\n    Rel(githubAction, packages, \"Verifies build\", \"nix build\")\n    Rel(githubAction, githubAction, \"Auto-commits changes\", \"git push\")\n\n    Rel(packages, nixpkgs, \"Inherits base derivation\", \"chromium wrapper\")\n\n    UpdateElementStyle(updateScript, $bgColor=\"#FF9800\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Continuous Packaging: GitHub Actions workflow runs daily at 12:00 UTC, automatically detecting and packaging new Brave releases without manual intervention</li> <li>Two-stage Update Process: Update script first queries GitHub API for latest release metadata, then uses <code>nix-prefetch-url</code> to compute SRI hashes for .deb assets before modifying package definitions</li> <li>Binary Wrapping: Packages don't compile Brave from source; instead they extract .deb files and wrap binaries with Nix-provided dependencies (similar to upstream nixpkgs chromium approach)</li> <li>Multi-consumption Pattern: Single flake provides three consumption methods: direct packages (environment.systemPackages), NixOS modules (programs.brave-nightly), and overlays (for custom pkgs)</li> <li>Flake Purity: All inputs locked in flake.lock; users can pin specific commits for stability or track master branch for continuous updates</li> <li>Channel Separation: Nightly and Beta are completely independent derivations, allowing users to install one or both simultaneously without conflicts</li> </ul>"},{"location":"brave-browser-previews/#onboarding","title":"Onboarding","text":""},{"location":"brave-browser-previews/#direct-execution-no-installation","title":"Direct Execution (No Installation)","text":"<p>You can run the browsers directly without installing them:</p> <pre><code># Run Nightly\nnix run github:kcalvelli/brave-browser-previews#brave-nightly\n\n# Run Beta\nnix run github:kcalvelli/brave-browser-previews#brave-beta\n</code></pre>"},{"location":"brave-browser-previews/#nixos-configuration","title":"NixOS Configuration","text":""},{"location":"brave-browser-previews/#step-1-add-flake-input","title":"Step 1: Add Flake Input","text":"<p>Add this repository to your <code>flake.nix</code> inputs:</p> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n    brave-previews.url = \"github:kcalvelli/brave-browser-previews\";\n\n    # Recommended: Follow your system's nixpkgs to avoid duplicate store paths\n    brave-previews.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = { self, nixpkgs, brave-previews, ... }: {\n    # Your configuration\n  };\n}\n</code></pre>"},{"location":"brave-browser-previews/#step-2-use-nixos-module","title":"Step 2: Use NixOS Module","text":"<p>Configure Brave Nightly similar to <code>programs.chromium</code>:</p> <pre><code>{ pkgs, brave-previews, ... }:\n\n{\n  imports = [\n    brave-previews.nixosModules.default\n  ];\n\n  programs.brave-nightly = {\n    enable = true;\n    extensions = [\n      \"cjpalhdlnbpafiamejdnhcphjbkeiagm\" # uBlock Origin\n    ];\n    defaultSearchProviderSearchURL = \"https://search.brave.com/search?q={searchTerms}\";\n  };\n\n  # You can also configure Beta independently\n  programs.brave-beta.enable = true;\n}\n</code></pre>"},{"location":"brave-browser-previews/#step-3-install-as-package-alternative","title":"Step 3: Install as Package (Alternative)","text":"<p>If you just want the packages without the configuration module:</p> <pre><code>{ pkgs, brave-previews, ... }:\n\n{\n  environment.systemPackages = [\n    brave-previews.packages.${pkgs.system}.brave-nightly\n  ];\n}\n</code></pre>"},{"location":"brave-browser-previews/#home-manager","title":"Home Manager","text":"<p>In your <code>home.nix</code>:</p> <pre><code>{ pkgs, brave-previews, ... }:\n\n{\n  home.packages = [\n    brave-previews.packages.${pkgs.system}.brave-nightly\n  ];\n}\n</code></pre>"},{"location":"brave-browser-previews/#release-history","title":"Release History","text":"Version Date Status - - No releases found"},{"location":"c64-stream-viewer/","title":"C64 Stream Viewer","text":"<p>Wayland-native viewer for Ultimate64 video/audio streaming with VIC-II color conversion</p> <p>View on GitHub</p>"},{"location":"c64-stream-viewer/#overview","title":"Overview","text":"<p>A Wayland-native video viewer for Ultimate64 video streaming that decodes the proprietary UDP packet format used by the Ultimate64 device. The application provides real-time video and audio playback with custom decoding for the 4-bit VIC-II color format.</p> <p>Key Features:</p> <ul> <li>Native Wayland Rendering: Uses SDL2/pygame with native Wayland support</li> <li>Custom Packet Decoder: Decodes Ultimate64's proprietary 4-bit VIC-II color format</li> <li>Real-time Performance: 14-17 FPS video display with ~4ms audio latency</li> <li>Format Auto-detection: Supports both PAL (384\u00d7272) and NTSC (384\u00d7240) resolutions</li> <li>Hardware-accelerated Scaling: Leverages SDL2 GPU scaling</li> <li>Synchronized Audio: 16-bit stereo PCM at 47976 Hz with pygame mixer</li> <li>Multiple Modes: Complete A/V viewer, video-only, headless statistics, and frame capture</li> </ul>"},{"location":"c64-stream-viewer/#architecture","title":"Architecture","text":"<p>The viewer operates as a multi-threaded UDP receiver that decodes proprietary streaming packets from Ultimate64 hardware, converts VIC-II palette data to RGB, and renders synchronized audio/video through Wayland. The architecture separates video and audio processing into independent pipelines.</p> <pre><code>C4Component\n    title Component Diagram for C64 Stream Viewer\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"C64 Enthusiast\", \"Viewing retro gaming or development\")\n\n    Container_Boundary(viewer_app, \"Viewer Application\") {\n        Component(videoDecoder, \"Video Decoder\", \"Python/NumPy\", \"Parses UDP packets, decodes 4-bit VIC-II palette to RGB\")\n        Component(audioDecoder, \"Audio Decoder\", \"Python\", \"Parses UDP packets, extracts 16-bit PCM samples\")\n        Component(renderer, \"Display Renderer\", \"Pygame/SDL2\", \"Renders frames to Wayland surface, handles scaling\")\n    }\n\n    Container_Boundary(audio_playback, \"Audio Subsystem\") {\n        Component(audioMixer, \"Audio Mixer\", \"Pygame Mixer\", \"Buffers and plays 47976 Hz stereo PCM\")\n    }\n\n    Container_Boundary(network_layer, \"Network Layer\") {\n        Component(videoSocket, \"Video Socket\", \"Python UDP Socket\", \"Receives on port 11000\")\n        Component(audioSocket, \"Audio Socket\", \"Python UDP Socket\", \"Receives on port 11001\")\n    }\n\n    System_Ext(ultimate64, \"Ultimate 64\", \"FPGA-based C64 Hardware\")\n    System_Ext(waylandCompositor, \"Wayland Compositor\", \"Niri/Sway/etc\")\n\n    Rel(user, renderer, \"Views stream, controls playback\", \"Keyboard: F=fullscreen, M=mute, ESC=quit\")\n\n    Rel(ultimate64, videoSocket, \"Streams video frames\", \"UDP port 11000, 780-byte packets\")\n    Rel(ultimate64, audioSocket, \"Streams audio samples\", \"UDP port 11001, 770-byte packets\")\n\n    Rel(videoSocket, videoDecoder, \"Forwards video packets\", \"780 bytes: 12-byte header + 768-byte payload\")\n    Rel(audioSocket, audioDecoder, \"Forwards audio packets\", \"770 bytes: 2-byte header + 768-byte payload\")\n\n    Rel(videoDecoder, renderer, \"Submits RGB frames\", \"384\u00d7272 PAL or 384\u00d7240 NTSC, NumPy array\")\n    Rel(audioDecoder, audioMixer, \"Submits PCM buffers\", \"192 stereo samples per packet\")\n\n    Rel(renderer, waylandCompositor, \"Renders surface\", \"SDL2 Wayland backend\")\n    Rel(audioMixer, user, \"Plays audio\", \"~4ms latency\")\n\n    UpdateElementStyle(videoDecoder, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(audioDecoder, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Dual UDP Stream: Ultimate64 transmits two independent UDP streams (video on 11000, audio on 11001) that must be received and synchronized by the viewer</li> <li>Proprietary Format: Video packets use a custom 12-byte header (seq, frame#, line#, dimensions, format) followed by 768 bytes of 4-bit indexed color data (4 lines \u00d7 384 pixels \u00d7 0.5 bytes)</li> <li>VIC-II Palette Conversion: Each 4-bit value indexes into the classic Commodore 64 VIC-II 16-color palette, which is converted to RGB888 for modern displays</li> <li>Multi-packet Frames: Single video frames span multiple UDP packets (272\u00f74 = 68 packets for PAL), requiring frame assembly logic with sequence tracking</li> <li>Audio Interleaving: Audio payload contains 16-bit signed PCM samples in stereo interleaved format (LRLRLR...), 192 samples per packet = 768 bytes</li> <li>Wayland-first Design: Explicitly sets SDL_VIDEODRIVER=wayland and uses pygame with SDL2 backend for native Wayland protocol support</li> <li>Three Execution Modes: Complete A/V viewer (default), video-only (lightweight), headless (statistics/capture) - all sharing core decoder logic</li> </ul>"},{"location":"c64-stream-viewer/#onboarding","title":"Onboarding","text":""},{"location":"c64-stream-viewer/#quick-start-run-without-installation","title":"Quick Start - Run Without Installation","text":"<p>Try the viewer directly without installing:</p> <pre><code># Complete A/V viewer (recommended)\nnix run github:kcalvelli/c64-stream-viewer#av\n\n# Video-only viewer (lightweight)\nnix run github:kcalvelli/c64-stream-viewer#video\n\n# Headless mode (statistics only)\nnix run github:kcalvelli/c64-stream-viewer#headless\n</code></pre>"},{"location":"c64-stream-viewer/#nixos-system-installation","title":"NixOS System Installation","text":"<p>Add as a flake input to your NixOS configuration. In your <code>flake.nix</code>:</p> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    c64-stream-viewer.url = \"github:kcalvelli/c64-stream-viewer\";\n  };\n\n  outputs = { self, nixpkgs, c64-stream-viewer }: {\n    nixosConfigurations.yourhostname = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n        {\n          environment.systemPackages = [\n            c64-stream-viewer.packages.x86_64-linux.av\n            # Optional: Add other variants\n            # c64-stream-viewer.packages.x86_64-linux.video\n            # c64-stream-viewer.packages.x86_64-linux.headless\n          ];\n        }\n      ];\n    };\n  };\n}\n</code></pre> <p>Then rebuild your system:</p> <pre><code>sudo nixos-rebuild switch --flake .#yourhostname\n</code></pre> <p>After installation, run from anywhere:</p> <pre><code>c64-stream-viewer-av\n</code></pre>"},{"location":"c64-stream-viewer/#development","title":"Development","text":"<p>Run from cloned repository:</p> <pre><code>cd ~/Projects/c64-stream-viewer\nnix run .#av            # Complete A/V viewer\nnix run .#video         # Video only\nnix run .#headless      # Headless mode\n</code></pre> <p>Or enter development shell:</p> <pre><code>nix develop\npython c64_stream_viewer_av.py\n</code></pre>"},{"location":"c64-stream-viewer/#usage-and-controls","title":"Usage and Controls","text":"<p>Complete A/V Viewer Controls:</p> <ul> <li><code>ESC</code> or <code>Q</code> - Quit</li> <li><code>F</code> - Toggle fullscreen</li> <li><code>M</code> - Mute/unmute audio</li> </ul> <p>Command-line Options:</p> <pre><code>python c64_stream_viewer_av.py --help\n  --video-port PORT    Video UDP port (default: 11000)\n  --audio-port PORT    Audio UDP port (default: 11001)\n  --scale N            Display scale factor (default: 2)\n  --fullscreen         Start in fullscreen\n  --no-audio           Disable audio\n</code></pre> <p>Frame Capture Mode:</p> <pre><code>python c64_stream_viewer.py --save-frames /path/to/output\n</code></pre> <p>Saves frames as PNG files for later viewing or processing.</p>"},{"location":"c64-stream-viewer/#technical-details","title":"Technical Details","text":"<p>Video Format:</p> <ul> <li>Packet Size: 780 bytes</li> <li>Header: 12 bytes (seq, frame#, line#, dimensions, format)</li> <li>Payload: 768 bytes of 4-bit indexed color data</li> <li>Format: 4 lines \u00d7 384 pixels \u00d7 0.5 bytes = 768 bytes</li> <li>Color Palette: 16-color VIC-II palette (converted to RGB)</li> </ul> <p>Audio Format:</p> <ul> <li>Packet Size: 770 bytes</li> <li>Header: 2 bytes (sequence number)</li> <li>Payload: 768 bytes = 192 stereo samples</li> <li>Format: 16-bit signed PCM, stereo, interleaved</li> <li>Sample Rate: 47976 Hz</li> <li>Latency: ~4ms per packet</li> </ul>"},{"location":"c64-stream-viewer/#release-history","title":"Release History","text":"Version Date Status v1.0.0 2025-12-31 \u2705 Latest"},{"location":"c64term/","title":"C64 Terminal","text":"<p>Terminal for Commodore 64</p> <p>View on GitHub</p>"},{"location":"c64term/#overview","title":"Overview","text":"<p>Authentic Commodore 64 terminal experience for modern Linux systems. C64 Term brings the classic C64 aesthetic to your modern terminal with authentic colors, PETSCII palette, boot screen, and blinking cursor - all powered by Ghostty and Fish shell.</p> <p>Key Features:</p> <ul> <li>Authentic C64 Colors: Classic blue background (#3e31a2) and light blue text (#7c70da)</li> <li>Full PETSCII Palette: Complete 16-color Commodore 64 color scheme</li> <li>C64 Boot Screen: Shows actual system RAM with \"READY.\" prompt</li> <li>Blinking Cursor: Classic block cursor \u2588</li> <li>Fish Shell Integration: Pre-configured with C64 color theme</li> <li>Ghostty Terminal: Modern GPU-accelerated terminal with C64 configuration</li> <li>BASIC Interpreter: Includes cbmbasic for authentic BASIC programming</li> </ul>"},{"location":"c64term/#architecture","title":"Architecture","text":"<p>C64 Term functions as a wrapper application that launches Ghostty terminal with a pre-configured C64 theme and Fish shell environment. The architecture separates the terminal emulator (Ghostty), shell configuration (Fish), and optional BASIC interpreter (cbmbasic) into distinct components orchestrated by a launcher script.</p> <pre><code>C4Component\n    title Component Diagram for C64 Terminal\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"Retro Computing Enthusiast\", \"Seeking C64 terminal experience\")\n\n    Container_Boundary(c64term_app, \"C64 Term Application\") {\n        Component(launcher, \"Launcher Script\", \"Bash\", \"Starts Ghostty with C64 config, sets XDG paths\")\n        Component(configManager, \"Config Manager\", \"Shell Script\", \"Generates isolated Ghostty config\")\n        Component(fishTheme, \"Fish Theme\", \"Fish Config\", \"C64 color scheme, boot screen, prompt\")\n    }\n\n    Container_Boundary(terminal_layer, \"Terminal Layer\") {\n        Component(ghostty, \"Ghostty Terminal\", \"GPU-accelerated Terminal\", \"Renders C64 colors, handles input\")\n        Component(fishShell, \"Fish Shell\", \"Interactive Shell\", \"User command environment\")\n    }\n\n    Container_Boundary(optional_components, \"Optional Components\") {\n        Component(cbmbasic, \"cbmbasic\", \"BASIC Interpreter\", \"Commodore BASIC 2.0 interpreter\")\n    }\n\n    System_Ext(waylandCompositor, \"Wayland Compositor\", \"Desktop Environment\")\n\n    Rel(user, launcher, \"Executes c64term\", \"Command line\")\n\n    Rel(launcher, configManager, \"Creates isolated config\", \"$XDG_RUNTIME_DIR/c64-xdg-config\")\n    Rel(configManager, ghostty, \"Provides C64 theme config\", \"ghostty.conf with palette\")\n\n    Rel(launcher, ghostty, \"Launches with custom env\", \"XDG_CONFIG_HOME override\")\n    Rel(ghostty, fishShell, \"Spawns shell\", \"fish --interactive\")\n\n    Rel(fishShell, fishTheme, \"Sources C64 config\", \"config.fish: boot screen, colors, prompt\")\n    Rel(fishTheme, user, \"Displays boot screen\", \"READY. prompt with system RAM\")\n\n    Rel(user, fishShell, \"Enters commands\", \"Standard shell interaction\")\n    Rel(user, cbmbasic, \"Runs BASIC interpreter\", \"Type 'basic' command\")\n\n    Rel(ghostty, waylandCompositor, \"Renders window\", \"Wayland protocol\")\n\n    UpdateElementStyle(ghostty, $bgColor=\"#3e31a2\", $fontColor=\"#7c70da\")\n    UpdateElementStyle(fishTheme, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Isolated Configuration: Uses <code>XDG_RUNTIME_DIR/c64-xdg-config/</code> to avoid interfering with user's main Ghostty setup, ensuring C64 theme doesn't affect other terminal instances</li> <li>Wrapper Pattern: Launcher script sets environment variables before executing Ghostty, decoupling C64 theming from terminal emulator</li> <li>Two-layer Theming: Ghostty provides color palette (16 PETSCII colors), Fish shell provides prompt and boot screen text</li> <li>Stateless Launcher: Each invocation regenerates isolated config directory, ensuring fresh C64 environment every launch</li> <li>Nix Packaging: Entire application packaged as a Nix flake with Ghostty, Fish, and cbmbasic as runtime dependencies</li> <li>BASIC Integration: cbmbasic (Commodore BASIC 2.0 interpreter) included in development shell, accessible via <code>basic</code> command</li> <li>GPU Acceleration: Leverages Ghostty's GPU rendering for smooth terminal experience with C64 aesthetics</li> </ul>"},{"location":"c64term/#onboarding","title":"Onboarding","text":""},{"location":"c64term/#quick-start-run-without-installation","title":"Quick Start - Run Without Installation","text":"<p>Try C64 Term directly without installing:</p> <pre><code>nix run github:kcalvelli/c64term\n</code></pre> <p>This will launch a Ghostty terminal with the authentic C64 experience.</p>"},{"location":"c64term/#nixos-system-installation","title":"NixOS System Installation","text":"<p>Add as a flake input to your NixOS configuration:</p> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    c64term.url = \"github:kcalvelli/c64term\";\n  };\n\n  outputs = { self, nixpkgs, c64term, ... }: {\n    nixosConfigurations.yourhostname = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n        {\n          environment.systemPackages = [\n            c64term.packages.x86_64-linux.c64term\n          ];\n        }\n      ];\n    };\n  };\n}\n</code></pre> <p>Then rebuild your system:</p> <pre><code>sudo nixos-rebuild switch --flake .#yourhostname\n</code></pre> <p>After installation, run from anywhere:</p> <pre><code>c64term\n</code></pre>"},{"location":"c64term/#home-manager-installation","title":"Home Manager Installation","text":"<p>In your <code>home.nix</code>:</p> <pre><code>{\n  inputs = {\n    c64term.url = \"github:kcalvelli/c64term\";\n  };\n\n  # In your home configuration\n  home.packages = [\n    inputs.c64term.packages.${pkgs.stdenv.hostPlatform.system}.c64term\n  ];\n}\n</code></pre>"},{"location":"c64term/#requirements","title":"Requirements","text":"<ul> <li>Ghostty terminal emulator (included in Nix package)</li> <li>Fish shell (included in Nix package)</li> <li>Linux system (x86_64 or aarch64)</li> </ul>"},{"location":"c64term/#usage","title":"Usage","text":"<p>Launch C64 Terminal:</p> <pre><code>c64term\n</code></pre> <p>You'll see an authentic C64 boot screen showing your actual system RAM, followed by the classic \"READY.\" prompt.</p> <p>Enter BASIC Interpreter:</p> <pre><code>basic\n</code></pre> <p>Exit BASIC:</p> <p>Type <code>SYSTEM</code> or press <code>Ctrl+C</code>.</p>"},{"location":"c64term/#configuration","title":"Configuration","text":"<p>C64 Term runs in an isolated configuration directory to avoid affecting your main Ghostty setup. Configuration is stored in <code>$XDG_RUNTIME_DIR/c64-xdg-config/</code>.</p>"},{"location":"c64term/#development","title":"Development","text":"<pre><code># Clone the repository\ngit clone https://github.com/kcalvelli/c64term\ncd c64term\n\n# Build the package\nnix build\n\n# Run directly\nnix run\n\n# Enter development shell with cbmbasic\nnix develop\n</code></pre>"},{"location":"c64term/#release-history","title":"Release History","text":"Version Date Status - - No releases found"},{"location":"kcalvelli-portal/","title":"Engineering Portal","text":"<p>Auto-updating portfolio site with GitHub discovery and architectural documentation.</p>"},{"location":"kcalvelli-portal/#overview","title":"Overview","text":"<p>This repository contains the source for Keith Calvelli's engineering portfolio - a static documentation site built with MkDocs Material that showcases public GitHub projects with architectural diagrams, onboarding guides, and release information.</p> <p>Repository: kcalvelli/kcalvelli-portal</p>"},{"location":"kcalvelli-portal/#architecture","title":"Architecture","text":"<pre><code>C4Component\n    title Engineering Portal - Component Diagram\n\n    Container_Boundary(portal, \"Engineering Portal\") {\n        Component(projects, \"projects.json\", \"JSON\", \"Project registry with tags and metadata\")\n        Component(ops, \"OPS_MANUAL.md\", \"Markdown\", \"Agent instructions for documentation generation\")\n        Component(docs, \"docs/\", \"Markdown\", \"Generated documentation pages\")\n        Component(mkdocs, \"mkdocs.yml\", \"YAML\", \"Site configuration and navigation\")\n    }\n\n    System_Ext(github, \"GitHub API\", \"Repository data source\")\n    System_Ext(claude, \"Claude Code\", \"AI assistant for updates\")\n    Person(user, \"Portfolio Viewer\", \"Visits the documentation site\")\n\n    Rel(claude, projects, \"Reads/updates\", \"JSON\")\n    Rel(claude, github, \"Scrapes repos\", \"gh CLI\")\n    Rel(claude, docs, \"Generates\", \"Markdown + Mermaid\")\n    Rel(ops, claude, \"Instructs\", \"Agent workflow\")\n    Rel(user, docs, \"Views\", \"HTTPS\")\n\n    UpdateElementStyle(portal, $bgColor=\"#1168bd\")</code></pre> <p>Key Components: - projects.json - Master registry of all documented projects with display names, descriptions, tags, and diagram types - OPS_MANUAL.md - Detailed instructions for the documentation generation workflow - OpenSpec - Spec-driven development framework for managing changes</p>"},{"location":"kcalvelli-portal/#onboarding","title":"Onboarding","text":""},{"location":"kcalvelli-portal/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nix with flakes enabled</li> <li>GitHub CLI (<code>gh</code>) authenticated</li> </ul>"},{"location":"kcalvelli-portal/#build-the-site","title":"Build the Site","text":"<pre><code># Enter development environment\nnix develop\n\n# Serve locally\nmkdocs serve\n\n# Build static site\nmkdocs build\n</code></pre>"},{"location":"kcalvelli-portal/#update-the-portal","title":"Update the Portal","text":"<p>When in Claude Code, simply say \"update\" to: 1. Discover new public repositories from GitHub 2. Auto-classify with tag suggestions 3. Regenerate all documentation pages 4. Update navigation</p>"},{"location":"kcalvelli-portal/#release-history","title":"Release History","text":"<p>No releases yet.</p>"},{"location":"mcp-gateway/","title":"MCP Gateway","text":"<p>Universal MCP Gateway - Aggregates MCP servers with REST, MCP HTTP transport, and OAuth2 authentication.</p>"},{"location":"mcp-gateway/#overview","title":"Overview","text":"<p>MCP Gateway aggregates multiple MCP (Model Context Protocol) servers behind a single interface, providing REST API access, native MCP HTTP transport support, and dynamic OpenAPI generation for tool integration.</p> <p>Repository: kcalvelli/mcp-gateway</p>"},{"location":"mcp-gateway/#architecture","title":"Architecture","text":"<pre><code>C4Component\n    title MCP Gateway - Component Diagram\n\n    Container_Boundary(gateway, \"MCP Gateway\") {\n        Component(rest, \"REST API\", \"FastAPI\", \"Tool management and execution\")\n        Component(mcp, \"MCP Transport\", \"HTTP\", \"Native MCP protocol (2025-06-18)\")\n        Component(openapi, \"Dynamic OpenAPI\", \"JSON\", \"Per-tool endpoints for Open WebUI\")\n        Component(ui, \"Web UI\", \"HTML/JS\", \"Visual orchestrator\")\n    }\n\n    System_Ext(servers, \"MCP Servers\", \"git, github, filesystem, etc.\")\n    System_Ext(clients, \"AI Clients\", \"Claude Code, Open WebUI, etc.\")\n    System_Ext(tailscale, \"Tailscale\", \"Network security\")\n\n    Rel(clients, rest, \"HTTP\", \"Tool calls\")\n    Rel(clients, mcp, \"MCP HTTP\", \"Native protocol\")\n    Rel(gateway, servers, \"stdio\", \"Server communication\")\n    Rel(tailscale, gateway, \"Secures\", \"Network access\")\n\n    UpdateElementStyle(gateway, $bgColor=\"#1168bd\")</code></pre> <p>Key Features: - REST API - Tool management and execution via HTTP - MCP HTTP Transport - Native MCP protocol support (2025-06-18 spec) - Dynamic OpenAPI - Per-tool endpoints for Open WebUI integration - Web UI - Visual orchestrator for managing servers and tools - Declarative Config - NixOS/home-manager modules for server configuration - Tailscale Integration - Network-level security via Tailscale Services</p>"},{"location":"mcp-gateway/#onboarding","title":"Onboarding","text":""},{"location":"mcp-gateway/#installation","title":"Installation","text":"<p>Add to your <code>flake.nix</code>:</p> <pre><code>{\n  inputs.mcp-gateway.url = \"github:kcalvelli/mcp-gateway\";\n\n  outputs = { self, nixpkgs, mcp-gateway, ... }: {\n    nixpkgs.overlays = [ mcp-gateway.overlays.default ];\n\n    home-manager.users.youruser = {\n      imports = [ mcp-gateway.homeManagerModules.default ];\n\n      services.mcp-gateway = {\n        enable = true;\n        autoEnable = [ \"git\" \"github\" ];\n        servers = {\n          git = {\n            enable = true;\n            command = \"${pkgs.mcp-server-git}/bin/mcp-server-git\";\n          };\n        };\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"mcp-gateway/#api-endpoints","title":"API Endpoints","text":"Endpoint Description <code>GET /api/servers</code> List all configured servers <code>GET /api/tools</code> List all available tools <code>POST /api/tools/{server}/{tool}</code> Execute a tool"},{"location":"mcp-gateway/#release-history","title":"Release History","text":"<p>No releases yet.</p>"},{"location":"mcp-journal/","title":"MCP Journal","text":"<p>Journal management via Model Context Protocol</p> <p>View on GitHub</p>"},{"location":"mcp-journal/#overview","title":"Overview","text":"<p>A Model Context Protocol (MCP) server providing read-only access to systemd journalctl. This server enables AI assistants to help debug system issues, analyze logs, and monitor services on Linux systems through natural language queries.</p> <p>Platform: Linux-only (requires systemd and journalctl)</p> <p>Key Features:</p> <ul> <li>Three Core Tools: logs.query (flexible filtering), logs.tail (recent logs), units.status (systemd unit status)</li> <li>Read-only Security: No system modifications, runs as invoking user, no privilege escalation</li> <li>Allowlist Protection: units.status restricted to approved units, prevents enumeration</li> <li>Resource Limits: Max 2000 entries, 30s timeout per query</li> <li>Shell-injection Safe: Uses subprocess argv arrays, no shell execution</li> <li>Comprehensive Testing: 9 acceptance tests passing, smoke test suite included</li> </ul> <p>Status: Working MVP with complete specifications</p>"},{"location":"mcp-journal/#architecture","title":"Architecture","text":"<p>The server implements a bridge/adapter pattern between MCP clients and systemd's journalctl/systemctl commands. It operates as a STDIO-based MCP server that translates tool calls into safe subprocess invocations, parses structured output, and enforces security policies. The architecture emphasizes read-only access with allowlist-based authorization.</p> <pre><code>C4Component\n    title Component Diagram for MCP Journal Server\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"User\", \"Interacting with AI assistant for log analysis\")\n\n    Container_Boundary(mcp_clients, \"MCP Client Layer\") {\n        Component(cline, \"Cline VSCode Extension\", \"MCP Client\", \"VSCode extension for AI assistance\")\n        Component(claudeDesktop, \"Claude Desktop\", \"Anthropic AI\", \"Desktop AI assistant\")\n        Component(mcpInspector, \"MCP Inspector\", \"Testing Tool\", \"Protocol testing and debugging\")\n    }\n\n    Container_Boundary(mcp_server, \"MCP Journal Server\") {\n        Component(mcpProtocol, \"MCP Protocol Handler\", \"Python/STDIO\", \"JSON-RPC 2.0 over stdin/stdout\")\n        Component(toolRouter, \"Tool Router\", \"Python\", \"Dispatches to 3 tools: logs.query, logs.tail, units.status\")\n        Component(securityLayer, \"Security Layer\", \"Python\", \"Allowlist enforcement, resource limits, input validation\")\n    }\n\n    Container_Boundary(systemd_adapter, \"Systemd Adapter Layer\") {\n        Component(journalctlWrapper, \"journalctl Wrapper\", \"Python subprocess\", \"Executes journalctl with --output=json\")\n        Component(systemctlWrapper, \"systemctl Wrapper\", \"Python subprocess\", \"Executes systemctl status with allowlist check\")\n        Component(fieldMapper, \"Field Mapper\", \"Python\", \"Maps journalctl fields per data-schemas.json\")\n    }\n\n    System_Ext(journald, \"systemd-journald\", \"System Service\")\n    System_Ext(systemd, \"systemd\", \"Init System\")\n\n    Rel(user, cline, \"Natural language log queries\", \"Chat in VSCode\")\n    Rel(user, claudeDesktop, \"System debugging requests\", \"Chat interface\")\n\n    BiRel(cline, mcpProtocol, \"MCP messages\", \"STDIO JSON-RPC\")\n    BiRel(claudeDesktop, mcpProtocol, \"MCP messages\", \"STDIO JSON-RPC\")\n    BiRel(mcpInspector, mcpProtocol, \"Test requests\", \"STDIO JSON-RPC\")\n\n    Rel(mcpProtocol, toolRouter, \"Tool invocation\", \"logs.query/logs.tail/units.status\")\n    Rel(toolRouter, securityLayer, \"Validate request\", \"Check limits, allowlist\")\n\n    Rel(securityLayer, journalctlWrapper, \"Query logs\", \"subprocess argv array\")\n    Rel(securityLayer, systemctlWrapper, \"Check unit status\", \"subprocess argv array\")\n\n    Rel(journalctlWrapper, journald, \"Read journal\", \"journalctl --output=json\")\n    Rel(systemctlWrapper, systemd, \"Query unit\", \"systemctl status\")\n\n    Rel(journalctlWrapper, fieldMapper, \"Raw journal entries\", \"JSON objects\")\n    Rel(fieldMapper, toolRouter, \"Mapped log entries\", \"Standardized fields\")\n    Rel(systemctlWrapper, toolRouter, \"Unit status text\", \"systemctl output\")\n\n    Rel(toolRouter, mcpProtocol, \"Tool results\", \"JSON response\")\n\n    UpdateElementStyle(securityLayer, $bgColor=\"#FF9800\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(toolRouter, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Three-layer Bridge Pattern: MCP clients \u2192 Adapter Server \u2192 systemd commands, with clear separation between protocol handling, business logic, and system integration</li> <li>STDIO-only Transport: Uses stdin/stdout for MCP communication (no SSE/HTTP), designed for local invocation by MCP clients like Claude Desktop or Cline</li> <li>Subprocess-based Integration: All systemd interaction happens through subprocess.run() with argv arrays (never shell=True), preventing shell injection</li> <li>JSON Output Parsing: Exclusively uses <code>journalctl --output=json</code> for machine-readable output, parses one JSON object per line</li> <li>Allowlist Security Model: units.status enforces a hardcoded allowlist of approved systemd units, prevents arbitrary unit enumeration</li> <li>Read-only by Design: No write operations, no privilege escalation, runs with permissions of invoking user (requires user in systemd-journal group)</li> <li>Resource Protection: Enforces max 2000 entries per query, 30s subprocess timeout, prevents resource exhaustion attacks</li> <li>Field Mapping: Translates journalctl's internal fields (MESSAGE, SYSLOG_IDENTIFIER, etc.) to user-friendly names per data-schemas.json specification</li> </ul>"},{"location":"mcp-journal/#onboarding","title":"Onboarding","text":""},{"location":"mcp-journal/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux system with systemd (Ubuntu, Fedora, Arch, NixOS, etc.)</li> <li>Python 3.8+</li> <li>User must be in <code>systemd-journal</code> group for full journal access</li> </ul>"},{"location":"mcp-journal/#quick-start","title":"Quick Start","text":"<p>Direct Python Execution:</p> <pre><code># Clone the repository\ngit clone https://github.com/kcalvelli/mcp-journal.git\ncd mcp-journal\n\n# Run the server (STDIO mode)\npython3 src/mcp_journal.py\n</code></pre> <p>Using Nix:</p> <pre><code># Run directly\nnix run github:kcalvelli/mcp-journal\n\n# Or enter development shell\nnix develop github:kcalvelli/mcp-journal\n</code></pre>"},{"location":"mcp-journal/#mcp-client-configuration","title":"MCP Client Configuration","text":"<p>Cline (VSCode Extension) - Recommended:</p> <p>Install Cline extension and add to settings:</p> <pre><code>{\n  \"mcpServers\": {\n    \"journal\": {\n      \"command\": \"python3\",\n      \"args\": [\"/absolute/path/to/mcp-journal/src/mcp_journal.py\"]\n    }\n  }\n}\n</code></pre> <p>For NixOS users:</p> <pre><code>{\n  \"mcpServers\": {\n    \"journal\": {\n      \"command\": \"nix\",\n      \"args\": [\"run\", \"github:kcalvelli/mcp-journal\"]\n    }\n  }\n}\n</code></pre> <p>Claude Desktop:</p> <p>Add to Claude Desktop configuration:</p> <pre><code>{\n  \"mcpServers\": {\n    \"journal\": {\n      \"command\": \"python3\",\n      \"args\": [\"/absolute/path/to/mcp-journal/src/mcp_journal.py\"]\n    }\n  }\n}\n</code></pre>"},{"location":"mcp-journal/#using-the-server","title":"Using the Server","text":"<p>Once configured, you can ask your AI assistant:</p> <ul> <li>\"Show me the last 20 nginx error logs\"</li> <li>\"What's the status of my SSH service?\"</li> <li>\"Find all logs from the last hour matching 'timeout'\"</li> <li>\"Show me kernel messages with priority error or higher\"</li> </ul>"},{"location":"mcp-journal/#available-tools","title":"Available Tools","text":"<p>1. logs.query - Flexible journal queries</p> <pre><code>{\n  \"name\": \"logs.query\",\n  \"arguments\": {\n    \"limit\": 20,\n    \"priority\": \"err\",\n    \"unit\": \"nginx.service\",\n    \"since\": \"2 hours ago\"\n  }\n}\n</code></pre> <p>2. logs.tail - Recent logs (last 1 minute)</p> <pre><code>{\n  \"name\": \"logs.tail\",\n  \"arguments\": {\n    \"unit\": \"sshd.service\"\n  }\n}\n</code></pre> <p>3. units.status - Systemd unit status (allowlist-protected)</p> <pre><code>{\n  \"name\": \"units.status\",\n  \"arguments\": {\n    \"unit\": \"systemd-journald.service\"\n  }\n}\n</code></pre>"},{"location":"mcp-journal/#testing","title":"Testing","text":"<p>Run acceptance tests:</p> <pre><code>python3 TESTS/acceptance_harness.py\n</code></pre> <p>Run smoke tests:</p> <pre><code>bash TESTS/smoke-test.sh\n</code></pre> <p>All tests passing: 9/9 acceptance tests</p>"},{"location":"mcp-journal/#security-considerations","title":"Security Considerations","text":"<ul> <li>Read-only: No system modifications possible</li> <li>Runs as invoking user: No privilege escalation</li> <li>Allowlist enforcement: units.status restricted to approved units</li> <li>Resource limits: Max 2000 entries, 30s timeout</li> <li>No shell injection: Uses subprocess argv arrays</li> <li>User must be in <code>systemd-journal</code> group for full access</li> </ul> <p>See <code>SPECS/08-security.md</code> in the repository for complete threat model.</p>"},{"location":"mcp-journal/#project-status","title":"Project Status","text":"<p>Completed (MVP):</p> <ul> <li>Python MCP server implementation (543 lines)</li> <li>All 3 tools: logs.query, logs.tail, units.status</li> <li>Field mapping per specification</li> <li>Allowlist enforcement</li> <li>Acceptance test harness (9 tests)</li> <li>Smoke tests</li> <li>Complete specifications (9 docs)</li> </ul> <p>In Progress:</p> <ul> <li><code>--allow-units</code> CLI flag</li> <li>Nix packaging improvements</li> <li>Unit tests with mocks</li> </ul> <p>Planned (v1.1):</p> <ul> <li>Rate limiting</li> <li>Field-level redaction</li> <li>CI/CD workflows</li> </ul>"},{"location":"mcp-journal/#release-history","title":"Release History","text":"Version Date Status - - No releases found"},{"location":"nix-devshell-mcp/","title":"Nix Devshell MCP","text":"<p>Creation of Nix devshells via Model Context Protocol</p> <p>View on GitHub</p>"},{"location":"nix-devshell-mcp/#overview","title":"Overview","text":"<p>A Model Context Protocol (MCP) server that enables AI assistants to generate and scaffold Nix flake development environments from template profiles. This server bridges the gap between natural language requests and complete Nix devshell setups, providing instant project scaffolding for common development stacks.</p> <p>Key Features:</p> <ul> <li>4 Profile Templates: TypeScript/Node.js, Python/FastAPI, Angular Frontend, Java Spring Boot</li> <li>Complete Scaffolding: Generates flake.nix, direnv configuration, and language-specific project files</li> <li>Non-destructive: Prevents overwriting existing files, safe to run in existing projects</li> <li>Customizable Options: Configure project name, versions, git initialization, and developer info</li> <li>Direnv Integration: Automatic .envrc generation for seamless shell activation</li> <li>Template Engine: Uses Handlebars for flexible profile templates</li> </ul>"},{"location":"nix-devshell-mcp/#architecture","title":"Architecture","text":"<p>The server implements a template-based code generation system that translates profile selections and configuration options into complete Nix flake environments. It operates as an MCP server that receives tool calls from AI clients, applies Handlebars templates, and writes scaffolding files to the filesystem while preventing destructive overwrites.</p> <pre><code>C4Component\n    title Component Diagram for Nix Devshell MCP Server\n\n    UpdateLayoutConfig($c4ShapeInRow=\"3\")\n\n    Person(user, \"Developer\", \"Requesting new Nix devshell setup\")\n\n    Container_Boundary(mcp_clients, \"MCP Client Layer\") {\n        Component(claudeDesktop, \"Claude Desktop\", \"Anthropic AI\", \"AI assistant for development\")\n        Component(cursor, \"Cursor IDE\", \"AI Editor\", \"Code editor with AI capabilities\")\n        Component(cline, \"Cline VSCode\", \"MCP Client\", \"VSCode AI extension\")\n    }\n\n    Container_Boundary(mcp_server, \"MCP Devshell Server\") {\n        Component(mcpProtocol, \"MCP Protocol Handler\", \"TypeScript/STDIO\", \"JSON-RPC 2.0 handler\")\n        Component(toolRouter, \"Tool Router\", \"TypeScript\", \"Routes create_devshell, list_profiles\")\n        Component(profileManager, \"Profile Manager\", \"TypeScript\", \"Loads and validates profile templates\")\n    }\n\n    Container_Boundary(template_engine, \"Template Engine Layer\") {\n        Component(handlebars, \"Handlebars Renderer\", \"TypeScript/Handlebars\", \"Renders templates with context\")\n        Component(fileWriter, \"File Writer\", \"TypeScript/fs\", \"Non-destructive file creation\")\n        Component(optionsResolver, \"Options Resolver\", \"TypeScript\", \"Merges defaults with user options\")\n    }\n\n    Container_Boundary(profile_templates, \"Profile Templates\") {\n        Component(tsNodeProfile, \"TypeScript/Node\", \"Handlebars Template\", \"Node.js project with TypeScript, ESM, ESLint\")\n        Component(pythonProfile, \"Python/FastAPI\", \"Handlebars Template\", \"FastAPI project with pytest, black, mypy\")\n        Component(angularProfile, \"Angular Frontend\", \"Handlebars Template\", \"Angular workspace with CLI\")\n        Component(javaProfile, \"Java Spring Boot\", \"Handlebars Template\", \"Spring Boot with Maven/Gradle\")\n    }\n\n    System_Ext(filesystem, \"Project Filesystem\", \"Developer's project directory\")\n    System_Ext(nixFlakes, \"Nix Flakes\", \"Nix package manager\")\n    System_Ext(direnv, \"direnv\", \"Environment loader\")\n\n    Rel(user, claudeDesktop, \"Request devshell\", \"Natural language: 'Create a Python FastAPI project'\")\n    Rel(user, cursor, \"Request devshell\", \"Chat: 'Set up TypeScript Node.js environment'\")\n\n    BiRel(claudeDesktop, mcpProtocol, \"MCP messages\", \"STDIO JSON-RPC\")\n    BiRel(cursor, mcpProtocol, \"MCP messages\", \"STDIO JSON-RPC\")\n    BiRel(cline, mcpProtocol, \"MCP messages\", \"STDIO JSON-RPC\")\n\n    Rel(mcpProtocol, toolRouter, \"Tool invocation\", \"create_devshell/list_profiles\")\n    Rel(toolRouter, profileManager, \"Load profile\", \"Profile name + options\")\n\n    Rel(profileManager, tsNodeProfile, \"Select template\", \"Profile: 'typescript-node'\")\n    Rel(profileManager, pythonProfile, \"Select template\", \"Profile: 'python-fastapi'\")\n    Rel(profileManager, angularProfile, \"Select template\", \"Profile: 'angular-frontend'\")\n    Rel(profileManager, javaProfile, \"Select template\", \"Profile: 'java-spring-boot'\")\n\n    Rel(profileManager, optionsResolver, \"Merge options\", \"User options + profile defaults\")\n    Rel(optionsResolver, handlebars, \"Render context\", \"Variables: projectName, version, name, email\")\n\n    Rel(handlebars, tsNodeProfile, \"Apply template\", \"Handlebars interpolation\")\n    Rel(handlebars, fileWriter, \"Generated content\", \"flake.nix, .envrc, package.json, etc.\")\n\n    Rel(fileWriter, filesystem, \"Write files\", \"Non-destructive: skip if exists\")\n\n    Rel(filesystem, direnv, \"Auto-load shell\", \".envrc: use flake\")\n    Rel(filesystem, nixFlakes, \"Build environment\", \"nix develop\")\n\n    Rel(fileWriter, toolRouter, \"Result summary\", \"Files created/skipped\")\n    Rel(toolRouter, mcpProtocol, \"Tool response\", \"JSON success/error\")\n\n    UpdateElementStyle(handlebars, $bgColor=\"#FF9800\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(profileManager, $bgColor=\"#2196F3\", $fontColor=\"#FFFFFF\")\n    UpdateElementStyle(user, $bgColor=\"#4CAF50\", $fontColor=\"#FFFFFF\")</code></pre> <p>Architectural Assumptions:</p> <ul> <li>Template-based Generation: All profiles are Handlebars templates stored in <code>templates/</code> directory, allowing easy addition of new language/framework profiles</li> <li>Two-tool API: Provides <code>list_profiles</code> (discovery) and <code>create_devshell</code> (generation), following MCP best practices for tool design</li> <li>Non-destructive Writes: File writer checks for existing files before writing, preventing accidental overwrites of user code</li> <li>Profile Metadata: Each profile includes metadata (description, defaultOptions, files array), stored alongside templates for consistency</li> <li>Option Merging: User options override profile defaults, which override global defaults (name, email, projectName)</li> <li>Direnv-first Workflow: Always generates .envrc for automatic shell activation, assuming direnv is the primary interaction method</li> <li>Flake-centric Design: All profiles generate flake.nix as the source of truth, other config files (package.json, pyproject.toml) are minimal wrappers</li> <li>Git Integration: Optional <code>gitAutoInit</code> flag runs <code>git init</code> and creates .gitignore, but never auto-commits</li> </ul>"},{"location":"nix-devshell-mcp/#onboarding","title":"Onboarding","text":""},{"location":"nix-devshell-mcp/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nix with flakes enabled</li> <li>direnv (recommended for automatic shell activation)</li> <li>Node.js/npm (for development only, not required for usage)</li> </ul>"},{"location":"nix-devshell-mcp/#quick-start-run-without-installation","title":"Quick Start - Run Without Installation","text":"<p>Try the server directly without installing:</p> <pre><code># Install in Claude Desktop (automatic server start)\nnpx @kcalvelli/nix-devshell-mcp install\n\n# Or run manually\nnpx @kcalvelli/nix-devshell-mcp\n</code></pre>"},{"location":"nix-devshell-mcp/#mcp-client-configuration","title":"MCP Client Configuration","text":"<p>Claude Desktop:</p> <p>Add to Claude Desktop configuration (<code>~/Library/Application Support/Claude/claude_desktop_config.json</code> on macOS):</p> <pre><code>{\n  \"mcpServers\": {\n    \"nix-devshell-mcp\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@kcalvelli/nix-devshell-mcp\"]\n    }\n  }\n}\n</code></pre> <p>Cursor IDE:</p> <p>Add to <code>.cursor/mcp.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"nix-devshell-mcp\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@kcalvelli/nix-devshell-mcp\"]\n    }\n  }\n}\n</code></pre> <p>Cline (VSCode Extension):</p> <p>Add to Cline MCP settings:</p> <pre><code>{\n  \"mcpServers\": {\n    \"nix-devshell-mcp\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@kcalvelli/nix-devshell-mcp\"]\n    }\n  }\n}\n</code></pre>"},{"location":"nix-devshell-mcp/#using-the-server","title":"Using the Server","text":"<p>Once configured, you can ask your AI assistant:</p> <ul> <li>\"Create a TypeScript Node.js project with Nix\"</li> <li>\"Set up a Python FastAPI development environment\"</li> <li>\"Scaffold an Angular frontend project with Nix flakes\"</li> <li>\"What Nix devshell profiles are available?\"</li> </ul>"},{"location":"nix-devshell-mcp/#available-tools","title":"Available Tools","text":"<p>1. list_profiles - Discover available templates</p> <p>Returns all available profile templates with descriptions:</p> <pre><code>{\n  \"name\": \"list_profiles\"\n}\n</code></pre> <p>2. create_devshell - Generate Nix devshell</p> <pre><code>{\n  \"name\": \"create_devshell\",\n  \"arguments\": {\n    \"projectPath\": \"/home/user/my-project\",\n    \"profile\": \"typescript-node\",\n    \"options\": {\n      \"projectName\": \"my-app\",\n      \"nodeVersion\": \"20\",\n      \"name\": \"Your Name\",\n      \"email\": \"your@email.com\",\n      \"gitAutoInit\": true\n    }\n  }\n}\n</code></pre>"},{"location":"nix-devshell-mcp/#available-profiles","title":"Available Profiles","text":"<p>1. typescript-node</p> <p>Full-stack TypeScript project with:</p> <ul> <li>Node.js (configurable version)</li> <li>TypeScript with strict config</li> <li>ESLint + Prettier</li> <li>Jest for testing</li> <li>ESM module system</li> <li>package.json scaffold</li> </ul> <p>2. python-fastapi</p> <p>Python FastAPI backend with:</p> <ul> <li>Python (configurable version)</li> <li>FastAPI + Uvicorn</li> <li>pytest for testing</li> <li>black + mypy + ruff</li> <li>pyproject.toml scaffold</li> <li>Virtual environment setup</li> </ul> <p>3. angular-frontend</p> <p>Angular frontend project with:</p> <ul> <li>Node.js + Angular CLI</li> <li>TypeScript strict mode</li> <li>Angular workspace config</li> <li>Development server setup</li> <li>package.json with Angular scripts</li> </ul> <p>4. java-spring-boot</p> <p>Java Spring Boot application with:</p> <ul> <li>JDK (configurable version)</li> <li>Spring Boot dependencies</li> <li>Maven or Gradle</li> <li>Project structure scaffold</li> <li>pom.xml or build.gradle</li> </ul>"},{"location":"nix-devshell-mcp/#development","title":"Development","text":"<p>Clone and build:</p> <pre><code>git clone https://github.com/kcalvelli/nix-devshell-mcp\ncd nix-devshell-mcp\n\n# Build the project\nnix build\n\n# Or use npm\nnpm install\nnpm run build\n</code></pre> <p>Run in development mode:</p> <pre><code>npm run dev\n</code></pre> <p>Add a new profile:</p> <ol> <li>Create template in <code>templates/&lt;profile-name&gt;/</code></li> <li>Add <code>profile.json</code> with metadata</li> <li>Create Handlebars templates for each file</li> <li>Update profile manager to register new profile</li> </ol>"},{"location":"nix-devshell-mcp/#nix-flake-usage","title":"Nix Flake Usage","text":"<p>Add as a flake input:</p> <pre><code>{\n  inputs = {\n    nix-devshell-mcp.url = \"github:kcalvelli/nix-devshell-mcp\";\n  };\n\n  outputs = { self, nixpkgs, nix-devshell-mcp }: {\n    # Use in your configuration\n  };\n}\n</code></pre> <p>Run the server:</p> <pre><code>nix run github:kcalvelli/nix-devshell-mcp\n</code></pre>"},{"location":"nix-devshell-mcp/#release-history","title":"Release History","text":"Version Date Status - - No releases found"},{"location":"orthoterm/","title":"Orthoterm","text":"<p>Orthodox calendar terminal application.</p>"},{"location":"orthoterm/#overview","title":"Overview","text":"<p>OrthoTerm is a command-line tool for fetching Orthodox Christian calendar data and generating iCal files. It provides easy access to daily saints, readings, and liturgical notes from the Orthodox calendar, with support for both Gregorian and Julian dates.</p> <p>Repository: kcalvelli/orthoterm</p>"},{"location":"orthoterm/#architecture","title":"Architecture","text":"<pre><code>C4Component\n    title OrthoTerm - Component Diagram\n\n    Container_Boundary(orthoterm, \"OrthoTerm\") {\n        Component(cli, \"CLI Interface\", \"Rust\", \"Command-line argument parsing\")\n        Component(fetcher, \"Calendar Fetcher\", \"Rust\", \"HTTP client with rate limiting\")\n        Component(parser, \"Data Parser\", \"Rust\", \"HTML to structured data\")\n        Component(ical, \"iCal Generator\", \"Rust\", \"Calendar file output\")\n    }\n\n    System_Ext(source, \"Holy Trinity Orthodox Church\", \"Calendar data source\")\n    System_Ext(fs, \"Local Filesystem\", \"XDG data directories\")\n    Person(user, \"User\", \"Orthodox Christian\")\n\n    Rel(user, cli, \"Runs\", \"Terminal\")\n    Rel(cli, fetcher, \"Requests year\", \"Internal\")\n    Rel(fetcher, source, \"Scrapes\", \"HTTPS with rate limiting\")\n    Rel(parser, fetcher, \"Processes\", \"HTML\")\n    Rel(ical, fs, \"Writes\", \".ics files\")\n\n    UpdateElementStyle(orthoterm, $bgColor=\"#1168bd\")</code></pre> <p>Key Features: - Fetch Orthodox calendar data for any year - Generate iCal files for calendar integration - Support for both Gregorian and Julian calendar dates - Local data storage using XDG base directories - Automatic caching of calendar data - Respectful scraping with rate limiting and exponential backoff</p> <p>Calendar Data Includes: - Daily saints and commemorations - Scripture readings from the Orthodox lectionary - Troparia and kontakia - Fasting guidelines - Major feast days</p>"},{"location":"orthoterm/#onboarding","title":"Onboarding","text":""},{"location":"orthoterm/#installation","title":"Installation","text":""},{"location":"orthoterm/#using-nix","title":"Using Nix","text":"<pre><code>nix develop  # Enter development shell\ncargo build\n</code></pre>"},{"location":"orthoterm/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/kcalvelli/orthoterm.git\ncd orthoterm\ncargo install --path .\n</code></pre>"},{"location":"orthoterm/#usage","title":"Usage","text":"<pre><code># Fetch current year's calendar data\northoterm\n\n# Fetch specific year's data\northoterm 2025\n\n# Generate iCal file for a year\northoterm -i 2025\n</code></pre>"},{"location":"orthoterm/#output-files","title":"Output Files","text":"<p>OrthoTerm stores data in XDG directories: - Calendar data: <code>~/.local/share/orthoterm/data/calendar_YEAR.json</code> - iCal files: <code>~/.local/share/orthoterm/ical/calendar_YEAR.ics</code></p>"},{"location":"orthoterm/#release-history","title":"Release History","text":"<p>No releases yet.</p>"},{"location":"peregrinatio-rpg/","title":"Peregrinatio RPG","text":"<p>A Roleplaying Game of Exile and Pilgrimage, AD 870.</p>"},{"location":"peregrinatio-rpg/#overview","title":"Overview","text":"<p>Peregrinatio is a tabletop roleplaying game set in 9th-century Europe, where players take on the roles of exiled pilgrims traveling through a world of faith, danger, and miraculous encounters. This repository contains the handouts, character sheets, and quick references styled in the manner of a medieval codex.</p> <p>Repository: kcalvelli/peregrinatio-rpg</p>"},{"location":"peregrinatio-rpg/#architecture","title":"Architecture","text":"<pre><code>C4Component\n    title Peregrinatio RPG - Component Diagram\n\n    Container_Boundary(codex, \"Codex Repository\") {\n        Component(sheets, \"Character Sheets\", \"Markdown\", \"Knight, Navigator, Monastic, Illuminator\")\n        Component(chronicle, \"Campaign Chronicle\", \"Markdown\", \"Living hagiography of the pilgrimage\")\n        Component(mission, \"Mission Materials\", \"Markdown\", \"Log, tracker, and narrator guides\")\n        Component(saints, \"Saints Reference\", \"Markdown\", \"d20 Intercession table\")\n    }\n\n    Person(narrator, \"Narrator\", \"Guides the sacred journey\")\n    Person(players, \"Players\", \"Pilgrims on the road\")\n\n    Rel(narrator, mission, \"Uses\", \"Scene flow guidance\")\n    Rel(players, sheets, \"Records\", \"Virtues and wounds\")\n    Rel(players, chronicle, \"Writes\", \"Fellowship memories\")\n    Rel(players, saints, \"Invokes\", \"Holy intercession\")\n\n    UpdateElementStyle(codex, $bgColor=\"#8b4513\")</code></pre> <p>Game Materials: - Character Sheets - Four archetypes: Knight, Navigator, Monastic, Illuminator - Campaign Chronicle - Record missions, relics, scars, and blessings - Mission Materials - Player log and narrator tracker - Saints Reference - d20 Intercession table with prayers</p>"},{"location":"peregrinatio-rpg/#onboarding","title":"Onboarding","text":""},{"location":"peregrinatio-rpg/#how-to-play","title":"How to Play","text":"<ol> <li>Begin with Character Sheets - Each player chooses Knight, Navigator, Monastic, or Illuminator. Record starting Virtues and Wounds.</li> <li>Keep the Mission Log - After each mission, players record what happened, what was learned, and any Virtue shifts.</li> <li>Narrator Guides with Tracker - Use <code>mission-tracker.md</code> to frame each mission's flow: Aftermath, Tasks, Challenge, Climax, Resolution.</li> <li>Record the Chronicle - Over time, fill <code>campaign-chronicle.md</code> with relics, scars, blessings, and memories.</li> <li>Call on the Saints - Use <code>saints-quick-roll.md</code> when the fellowship invokes holy aid.</li> </ol>"},{"location":"peregrinatio-rpg/#repository-contents","title":"Repository Contents","text":"File Purpose <code>character-sheet-*.md</code> Player character sheets by archetype <code>campaign-chronicle.md</code> Living hagiography of the pilgrimage <code>mission-log.md</code> Player-facing mission record <code>mission-tracker.md</code> Narrator-facing guide <code>narrator-quick-reference.md</code> Quick rules reference <code>saints-quick-roll.md</code> d20 Intercession table"},{"location":"peregrinatio-rpg/#release-history","title":"Release History","text":"<p>No releases yet.</p>"}]}